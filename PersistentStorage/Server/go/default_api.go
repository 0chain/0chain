/*
 * 0chain Services
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 0.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"net/http"
	"log"
	"fmt"
	"encoding/json"
	ZC "./0chain"
)

const (
	log_level = 10 
	log_info = 3
	log_warn = 2
	log_bad = 1
)


func LogWithLevel(messsage string, level int) {
	if (log_level > level){
		log.Printf("%s", messsage)
	}
}


func ClientsDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	var DelClient Client
	err := json.NewDecoder(r.Body).Decode(&DelClient)
	if err != nil {
		LogWithLevel(err.Error(), log_bad)
		return
	}

	log_message := fmt.Sprintf("Del client request {ClientID: %s, PublicKey: %s}\n", 
		DelClient.Clientid, 
		DelClient.PublicKey)
	
	LogWithLevel(log_message, log_info)

	DelSuccess, Del_err  := ZC.DelClient(ZC.ZCClient(DelClient))
	if !DelSuccess {
		LogWithLevel("Connection to database failed\n", log_bad)
		LogWithLevel(Del_err.Error(), log_bad)
		jResponse := Response{Title: "Delete Result", Code: "FAILED", Message: "Unable to Delete client."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{

		jResponse := Response{Title: "Delete Result", Code: "Success", Message: "Client deleted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}
}

func ClientsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	var GetClient Client
	err := json.NewDecoder(r.Body).Decode(&GetClient)
	if err != nil {
		LogWithLevel(err.Error(), log_bad)
		return
	}

	log_message := fmt.Sprintf("Get client request {ClientID: %s, PublicKey: %s}\n", 
		GetClient.Clientid, 
		GetClient.PublicKey)
	
	LogWithLevel(log_message, log_info)

	ReturnedClient, GetSuccess, Get_err  := ZC.GetClient(ZC.ZCClient(GetClient))
	if !GetSuccess {
		LogWithLevel("Connection to database failed\n", log_bad)
		LogWithLevel(Get_err.Error(), log_bad)
		jResponse := Response{Title: "Get Result", Code: "FAILED", Message: "Unable to Get client."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		json.NewEncoder(w).Encode(ReturnedClient)
		log_message := fmt.Sprintf("Response: %v", ReturnedClient)
		LogWithLevel(log_message, log_info)
		return
	}
}

func ClientsPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
//	w.WriteHeader(http.StatusNotFound)
	http.Redirect(w, r, "/", http.StatusNotFound)
	log_message := fmt.Sprintf("404 message for client patch.\n%v\n%v\n", w, r)
	LogWithLevel(log_message, log_warn)
}

func ClientsPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	var NewClient Client
	err := json.NewDecoder(r.Body).Decode(&NewClient)
	if err != nil {
		LogWithLevel(err.Error(), log_bad)
		return
	}

	log_message := fmt.Sprintf("New client request {ClientID: %s, PublicKey: %s}\n", 
		NewClient.Clientid, 
		NewClient.PublicKey)
	
	LogWithLevel(log_message, log_info)

	insertSuccess, insert_err  := ZC.InsertClient(ZC.ZCClient(NewClient))
	if !insertSuccess {
		LogWithLevel("Connection to database failed\n", log_bad)
		LogWithLevel(insert_err.Error(), log_bad)
		jResponse := Response{Title: "Insert Result", Code: "FAILED", Message: "Unable to insert client."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		jResponse := Response{Title: "Insert Result", Code: "Success", Message: "Client inserted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}
}

func TransactionsDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	var DelTransaction Transaction
	err := json.NewDecoder(r.Body).Decode(&DelTransaction)
	if err != nil {
		LogWithLevel(err.Error(), log_bad)
		return
	}

	log_message := fmt.Sprintf("Del transaction request {ClientID: %s, Transaction_data: %s, createdate: %s, Hash: %s, Signature: %s}\n", 
		DelTransaction.Clientid,
		DelTransaction.TransactionData,
		DelTransaction.Createdate,
		DelTransaction.Hash,
		DelTransaction.Signature)
	
	LogWithLevel(log_message, log_info)

	DelSuccess, Del_err  := ZC.DelTransaction(ZC.ZCTransaction(DelTransaction))
	if !DelSuccess {
		LogWithLevel("Connection to database failed\n", log_bad)
		LogWithLevel(Del_err.Error(), log_bad)
		jResponse := Response{Title: "Delete Result", Code: "FAILED", Message: "Unable to Delete transaction."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{

		jResponse := Response{Title: "Delete Result", Code: "Success", Message: "Transaction deleted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}

}

func TransactionsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	var GetTransaction Transaction
	err := json.NewDecoder(r.Body).Decode(&GetTransaction)
	if err != nil {
		LogWithLevel(err.Error(), log_bad)
		return
	}

	log_message := fmt.Sprintf("Get transaction request {ClientID: %s, Transaction_data: %s, createdate: %s, Hash: %s, Signature: %s}\n", 
		GetTransaction.Clientid,
		GetTransaction.TransactionData,
		GetTransaction.Createdate,
		GetTransaction.Hash,
		GetTransaction.Signature)
	
	LogWithLevel(log_message, log_info)

	ReturnedTransaction, GetSuccess, Get_err  := ZC.GetTransaction(ZC.ZCTransaction(GetTransaction))
	if !GetSuccess {
		LogWithLevel("Connection to database failed\n", log_bad)
		LogWithLevel(Get_err.Error(), log_bad)
		jResponse := Response{Title: "Get Transaction Result", Code: "FAILED", Message: "Unable to Get transaction."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		json.NewEncoder(w).Encode(ReturnedTransaction)
		log_message := fmt.Sprintf("Get Transaction Response: %v", ReturnedTransaction)
		LogWithLevel(log_message, log_info)
		return
	}
}

func TransactionsPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
//	w.WriteHeader(http.StatusOK)
	http.Redirect(w, r, "/", http.StatusNotFound)
	log_message := fmt.Sprintf("404 message for transaction patch. \n%v\n%v\n", w, r)
	LogWithLevel(log_message, log_warn)
}

func TransactionsPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	var NewTransaction Transaction
	err := json.NewDecoder(r.Body).Decode(&NewTransaction)
	if err != nil {
		LogWithLevel(err.Error(), log_bad)
		return
	}

	log_message := fmt.Sprintf("New transaction request {ClientID: %s, Transaction_data: %s, createdate: %s, Hash: %s, Signature: %s}\n", 
		NewTransaction.Clientid,
		NewTransaction.TransactionData,
		NewTransaction.Createdate,
		NewTransaction.Hash,
		NewTransaction.Signature)
	
	LogWithLevel(log_message, log_info)

	insertSuccess, insert_err  := ZC.InsertTransaction(ZC.ZCTransaction(NewTransaction))
	if !insertSuccess {
		LogWithLevel("Connection to database failed\n", log_bad)
		LogWithLevel(insert_err.Error(), log_bad)
		jResponse := Response{Title: "Insert Result", Code: "FAILED", Message: "Unable to insert transaction."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		jResponse := Response{Title: "Insert Result", Code: "Success", Message: "Transaction inserted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}
}
