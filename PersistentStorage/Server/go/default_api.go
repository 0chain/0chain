/*
 * 0chain Persistent Storage Services
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 0.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"net/http"
	"log"
	"fmt"
	"encoding/json"
	ZC "./0chain"
)

const (
	log_level = 10
	log_info = 3
	log_warn = 2
	log_error = 1
	log_system = 0

	RESPONSE_CODE_OK = "OK"
	RESPONSE_CODE_ERROR = "ERROR"
	RESPONSE_CODE_WARN = "WARN"
)

func LogWithLevel(messsage string, level int) {
	var  log_level_string [4]string
	log_level_string[log_info] = "INFO"
	log_level_string[log_warn] = "WARN"
	log_level_string[log_error] = "ERROR"
	log_level_string[log_system] = "SYSTEM"

	if (log_level > level){
		log.Printf("[%s] - %s", log_level_string[level], messsage)
	}
}

func ClientsDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	function_string := "Delete Client"
	var DelClient Client
	err := json.NewDecoder(r.Body).Decode(&DelClient)
	if err != nil {
		LogWithLevel(err.Error(), log_error)
		return
	}

	log_message := fmt.Sprintf("%s request {ClientID: %s, PublicKey: %s}\n", 
		function_string,
		DelClient.Clientid, 
		DelClient.PublicKey)
	
	LogWithLevel(log_message, log_info)

	DelSuccess, Del_err  := ZC.DelClient(ZC.ZCClient(DelClient))
	if !DelSuccess {
		LogWithLevel("Connection to database failed\n", log_error)
		LogWithLevel(Del_err.Error(), log_error)
		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_ERROR, Message: "Unable to Delete client."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{

		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_OK, Message: "Client deleted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}
}

func ClientsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	function_string := "Get Client"
	var GetClient Client
	err := json.NewDecoder(r.Body).Decode(&GetClient)
	if err != nil {
		LogWithLevel(err.Error(), log_error)
		return
	}

	log_message := fmt.Sprintf("%s request {ClientID: %s, PublicKey: %s}\n", 
		function_string,
		GetClient.Clientid, 
		GetClient.PublicKey)
	
	LogWithLevel(log_message, log_info)

	ReturnedClient, GetSuccess, Get_err  := ZC.GetClient(ZC.ZCClient(GetClient))

	//Convert 0chain client struct to swagger client struct
	var ReturnedClient_cvt ClientResponseClient
	ReturnedClient_cvt = ClientResponseClient(ReturnedClient)
	if !GetSuccess {
		LogWithLevel("Connection to database failed\n", log_error)
		LogWithLevel(Get_err.Error(), log_error)
		jClient_Response := ClientResponse{Title: function_string, Code: RESPONSE_CODE_ERROR, Message: "Unable to Get client."} 
		jClient_Response.Client = &ReturnedClient_cvt
		json.NewEncoder(w).Encode(jClient_Response)
		log_message := fmt.Sprintf("ClientResponse: %v", jClient_Response)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		jClient_Response := ClientResponse{Title: function_string, Code: RESPONSE_CODE_OK, Message: "Retrieved client."} 
		jClient_Response.Client = &ReturnedClient_cvt
		json.NewEncoder(w).Encode(jClient_Response)
		log_message := fmt.Sprintf("ClientResponse: %v", jClient_Response)
		LogWithLevel(log_message, log_info)
		return
	}
}

func ClientsPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
//	w.WriteHeader(http.StatusNotFound)
	http.Redirect(w, r, "/", http.StatusNotFound)
	log_message := fmt.Sprintf("404 message for client patch.\n%v\n%v\n", w, r)
	LogWithLevel(log_message, log_warn)
}

func ClientsPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	function_string := "Post Client"
	var NewClient Client
	err := json.NewDecoder(r.Body).Decode(&NewClient)
	if err != nil {
		LogWithLevel(err.Error(), log_error)
		return
	}

	log_message := fmt.Sprintf("%s request {ClientID: %s, PublicKey: %s}\n", 
		function_string,
		NewClient.Clientid, 
		NewClient.PublicKey)
	
	LogWithLevel(log_message, log_info)

	insertSuccess, insert_err  := ZC.InsertClient(ZC.ZCClient(NewClient))
	if !insertSuccess {
		LogWithLevel("Connection to database failed\n", log_error)
		LogWithLevel(insert_err.Error(), log_error)
		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_ERROR, Message: "Unable to insert client."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_OK, Message: "Client inserted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}

}

func TransactionsDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	function_string := "Delete Transaction"
	var DelTransaction Transaction
	err := json.NewDecoder(r.Body).Decode(&DelTransaction)
	if err != nil {
		LogWithLevel(err.Error(), log_error)
		return
	}

	log_message := fmt.Sprintf("%s request {ClientID: %s, Transaction_data: %s, createdate: %s, Hash: %s, Signature: %s}\n", 
		function_string, 
		DelTransaction.Clientid,
		DelTransaction.TransactionData,
		DelTransaction.Createdate,
		DelTransaction.Hash,
		DelTransaction.Signature)
	
	LogWithLevel(log_message, log_info)

	DelSuccess, Del_err  := ZC.DelTransaction(ZC.ZCTransaction(DelTransaction))
	if !DelSuccess {
		LogWithLevel("Connection to database failed\n", log_error)
		LogWithLevel(Del_err.Error(), log_error)
		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_ERROR, Message: "Unable to Delete transaction."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_OK, Message: "Transaction deleted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}
}

func TransactionsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	function_string := "Get Transaction"
	var GetTransaction Transaction
	err := json.NewDecoder(r.Body).Decode(&GetTransaction)
	if err != nil {
		LogWithLevel(err.Error(), log_error)
		return
	}

	log_message := fmt.Sprintf("%s request {ClientID: %s, Transaction_data: %s, createdate: %s, Hash: %s, Signature: %s}\n", 
		function_string,
		GetTransaction.Clientid,
		GetTransaction.TransactionData,
		GetTransaction.Createdate,
		GetTransaction.Hash,
		GetTransaction.Signature)
	
	LogWithLevel(log_message, log_info)

	ReturnedTransaction, GetSuccess, Get_err  := ZC.GetTransaction(ZC.ZCTransaction(GetTransaction))
	var ReturnedTransaction_cvt TransactionResponseTransaction
	ReturnedTransaction_cvt = TransactionResponseTransaction(ReturnedTransaction)
	if !GetSuccess {
		LogWithLevel("Connection to database failed\n", log_error)
		LogWithLevel(Get_err.Error(), log_error)
		jResponse := TransactionResponse{Title: function_string, Code: RESPONSE_CODE_ERROR, Message: "Unable to Get transaction."}
		jResponse.Transaction = &ReturnedTransaction_cvt
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("TransactionResponse: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		jResponse := TransactionResponse{Title: function_string, Code: RESPONSE_CODE_OK, Message: "Retrieved transaction."}
		jResponse.Transaction = &ReturnedTransaction_cvt
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Get Transaction TransactionResponse: %v", ReturnedTransaction)
		LogWithLevel(log_message, log_info)
		return
	}
}

func TransactionsPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
//	w.WriteHeader(http.StatusOK)
	http.Redirect(w, r, "/", http.StatusNotFound)
	log_message := fmt.Sprintf("404 message for transaction patch. \n%v\n%v\n", w, r)
	LogWithLevel(log_message, log_warn)
}

func TransactionsPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	function_string := "Post Transaction"
	var NewTransaction Transaction
	err := json.NewDecoder(r.Body).Decode(&NewTransaction)
	if err != nil {
		LogWithLevel(err.Error(), log_error)
		return
	}

	log_message := fmt.Sprintf("%s request {ClientID: %s, Transaction_data: %s, createdate: %s, Hash: %s, Signature: %s}\n", 
		function_string,
		NewTransaction.Clientid,
		NewTransaction.TransactionData,
		NewTransaction.Createdate,
		NewTransaction.Hash,
		NewTransaction.Signature)
	
	LogWithLevel(log_message, log_info)

	insertSuccess, insert_err  := ZC.InsertTransaction(ZC.ZCTransaction(NewTransaction))
	if !insertSuccess {
		LogWithLevel("Connection to database failed\n", log_error)
		LogWithLevel(insert_err.Error(), log_error)
		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_ERROR, Message: "Unable to insert transaction."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_warn)
		return
	}else{
		jResponse := Response{Title: function_string, Code: RESPONSE_CODE_OK, Message: "Transaction inserted."}
		json.NewEncoder(w).Encode(jResponse)
		log_message := fmt.Sprintf("Response: %v", jResponse)
		LogWithLevel(log_message, log_info)
		return
	}
}
