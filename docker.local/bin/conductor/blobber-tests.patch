diff --git a/code/go/0chain.net/blobbercore/handler/handler.go b/code/go/0chain.net/blobbercore/handler/handler.go
index 96442cb..a3fe8b8 100644
--- a/code/go/0chain.net/blobbercore/handler/handler.go
+++ b/code/go/0chain.net/blobbercore/handler/handler.go
@@ -1,3 +1,5 @@
+// +build !integration_tests
+
 package handler
 
 import (
diff --git a/code/go/0chain.net/blobbercore/handler/handler_integration_tests.go b/code/go/0chain.net/blobbercore/handler/handler_integration_tests.go
new file mode 100644
index 0000000..a24d811
--- /dev/null
+++ b/code/go/0chain.net/blobbercore/handler/handler_integration_tests.go
@@ -0,0 +1,345 @@
+// +build integration_tests
+
+//
+// the bad blobber behavior
+//
+
+//
+package handler
+
+import (
+	"context"
+	"net/http"
+	"os"
+	"runtime/pprof"
+
+	"0chain.net/blobbercore/config"
+	"0chain.net/blobbercore/constants"
+	"0chain.net/blobbercore/datastore"
+	"0chain.net/blobbercore/stats"
+	"0chain.net/core/common"
+
+	. "0chain.net/core/logging"
+
+	"github.com/gorilla/mux"
+)
+
+var storageHandler StorageHandler
+
+func GetMetaDataStore() *datastore.Store {
+	return datastore.GetStore()
+}
+
+/*SetupHandlers sets up the necessary API end points */
+func SetupHandlers(r *mux.Router) {
+	//object operations
+	r.HandleFunc("/v1/file/upload/{allocation}", common.ToJSONResponse(WithConnection(UploadHandler)))
+	r.HandleFunc("/v1/file/download/{allocation}", common.ToByteStream(WithConnection(DownloadHandler)))
+	r.HandleFunc("/v1/file/rename/{allocation}", common.ToJSONResponse(WithConnection(RenameHandler)))
+	r.HandleFunc("/v1/file/copy/{allocation}", common.ToJSONResponse(WithConnection(CopyHandler)))
+
+	r.HandleFunc("/v1/connection/commit/{allocation}", common.ToJSONResponse(WithConnection(CommitHandler)))
+	r.HandleFunc("/v1/file/commitmetatxn/{allocation}", common.ToJSONResponse(WithConnection(CommitMetaTxnHandler)))
+
+	//object info related apis
+	r.HandleFunc("/allocation", common.ToJSONResponse(WithConnection(AllocationHandler)))
+	r.HandleFunc("/v1/file/meta/{allocation}", common.ToJSONResponse(WithReadOnlyConnection(FileMetaHandler)))
+	r.HandleFunc("/v1/file/stats/{allocation}", common.ToJSONResponse(WithReadOnlyConnection(FileStatsHandler)))
+	r.HandleFunc("/v1/file/list/{allocation}", common.ToJSONResponse(WithReadOnlyConnection(ListHandler)))
+	r.HandleFunc("/v1/file/objectpath/{allocation}", common.ToJSONResponse(WithReadOnlyConnection(ObjectPathHandler)))
+	r.HandleFunc("/v1/file/referencepath/{allocation}", common.ToJSONResponse(WithReadOnlyConnection(ReferencePathHandler)))
+	r.HandleFunc("/v1/file/objecttree/{allocation}", common.ToJSONResponse(WithReadOnlyConnection(ObjectTreeHandler)))
+
+	//admin related
+	r.HandleFunc("/_debug", common.ToJSONResponse(DumpGoRoutines))
+	r.HandleFunc("/_config", common.ToJSONResponse(GetConfig))
+	r.HandleFunc("/_stats", stats.StatsHandler)
+	r.HandleFunc("/_statsJSON", common.ToJSONResponse(stats.StatsJSONHandler))
+	r.HandleFunc("/_cleanupdisk", common.ToJSONResponse(WithReadOnlyConnection(CleanupDiskHandler)))
+	r.HandleFunc("/getstats", common.ToJSONResponse(stats.GetStatsHandler))
+}
+
+func WithReadOnlyConnection(handler common.JSONResponderF) common.JSONResponderF {
+	return func(ctx context.Context, r *http.Request) (interface{}, error) {
+		ctx = GetMetaDataStore().CreateTransaction(ctx)
+		res, err := handler(ctx, r)
+		defer func() {
+			GetMetaDataStore().GetTransaction(ctx).Rollback()
+		}()
+		return res, err
+	}
+}
+
+func WithConnection(handler common.JSONResponderF) common.JSONResponderF {
+	return func(ctx context.Context, r *http.Request) (interface{}, error) {
+		ctx = GetMetaDataStore().CreateTransaction(ctx)
+		res, err := handler(ctx, r)
+		defer func() {
+			if err != nil {
+				GetMetaDataStore().GetTransaction(ctx).Rollback()
+			}
+		}()
+		if err != nil {
+			Logger.Error("Error in handling the request." + err.Error())
+			return res, err
+		}
+		err = GetMetaDataStore().GetTransaction(ctx).Commit().Error
+		if err != nil {
+			return res, common.NewError("commit_error", "Error committing to meta store")
+		}
+		return res, err
+	}
+}
+
+func AllocationHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+
+	response, err := storageHandler.GetAllocationDetails(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	return response, nil
+}
+
+func revertString(s string) string {
+	r := []rune(s)
+	for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
+		r[i], r[j] = r[j], r[i]
+	}
+	return string(r)
+}
+
+func FileMetaHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+
+	response, err := storageHandler.GetFileMeta(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	x := response.(map[string]interface{})
+	if hash, ok := x["hash"]; ok {
+		if str, ok := hash.(string); ok {
+			x["hash"] = revertString(str) // provide wrong hash
+		}
+	}
+
+	return response, nil
+}
+
+func CommitMetaTxnHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+
+	response, err := storageHandler.AddCommitMetaTxn(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	x := response.(struct {
+		Msg string `json:"msg"`
+	})
+	x.Msg = "Failure" // replace message
+
+	return x, nil
+}
+
+func FileStatsHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+
+	response, err := storageHandler.GetFileStats(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	return response, nil
+}
+
+/*DownloadHandler is the handler to respond to download requests from clients*/
+func DownloadHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+
+	response, err := storageHandler.DownloadFile(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	dr := response.(*DownloadResponse)
+	dr.Path = "/injection/" + dr.Path
+
+	return response, nil
+}
+
+/*ListHandler is the handler to respond to upload requests fro clients*/
+func ListHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+
+	response, err := storageHandler.ListEntities(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	response.AllocationRoot = revertString(response.AllocationRoot)
+	return response, nil
+}
+
+/*CommitHandler is the handler to respond to upload requests fro clients*/
+func CommitHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+
+	response, err := storageHandler.CommitWrite(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	response.AllocationRoot = revertString(response.AllocationRoot)
+	return response, nil
+}
+
+func ReferencePathHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+
+	response, err := storageHandler.GetReferencePath(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	if response.ReferencePath != nil && response.ReferencePath.Meta != nil {
+		response.ReferencePath.Meta["hash"] =
+			revertString(response.ReferencePath.Meta["hash"].(string))
+	}
+
+	return response, nil
+}
+
+func ObjectPathHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+
+	response, err := storageHandler.GetObjectPath(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	response.FileBlockNum += 20
+	response.RootHash = revertString(response.RootHash)
+	response.RefID += 12
+
+	return response, nil
+}
+
+func ObjectTreeHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+
+	response, err := storageHandler.GetObjectTree(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	if len(response.List) > 0 {
+		response.List = append(response.List, response.List[0])
+	}
+
+	return response, nil
+}
+
+func RenameHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+	response, err := storageHandler.RenameObject(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	ur := response.(*UploadResult)
+	ur.Filename = "/injected/" + ur.Filename
+
+	return response, nil
+}
+
+func CopyHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+	response, err := storageHandler.CopyObject(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	ur := response.(*UploadResult)
+	ur.Filename = "/injected/" + ur.Filename
+
+	return response, nil
+}
+
+/*UploadHandler is the handler to respond to upload requests fro clients*/
+func UploadHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	vars := mux.Vars(r)
+	ctx = context.WithValue(ctx, constants.ALLOCATION_CONTEXT_KEY, vars["allocation"])
+	ctx = context.WithValue(ctx, constants.CLIENT_CONTEXT_KEY, r.Header.Get(common.ClientHeader))
+	ctx = context.WithValue(ctx, constants.CLIENT_KEY_CONTEXT_KEY, r.Header.Get(common.ClientKeyHeader))
+	response, err := storageHandler.WriteFile(ctx, r)
+	if err != nil {
+		return nil, err
+	}
+
+	response.Filename = "/injected/" + response.Filename
+
+	return response, nil
+}
+
+func HandleShutdown(ctx context.Context) {
+	go func() {
+		select {
+		case <-ctx.Done():
+			Logger.Info("Shutting down server")
+			datastore.GetStore().Close()
+		}
+	}()
+}
+
+func DumpGoRoutines(ctx context.Context, r *http.Request) (interface{}, error) {
+	pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
+	return "success", nil
+}
+
+func GetConfig(ctx context.Context, r *http.Request) (interface{}, error) {
+	return config.Configuration, nil
+}
+
+func CleanupDiskHandler(ctx context.Context, r *http.Request) (interface{}, error) {
+	err := CleanupDiskFiles(ctx)
+	return "cleanup", err
+}
diff --git a/docker.local/BadBlobberDockerfile b/docker.local/BadBlobberDockerfile
new file mode 100644
index 0000000..a887062
--- /dev/null
+++ b/docker.local/BadBlobberDockerfile
@@ -0,0 +1,43 @@
+FROM golang:1.11.4-alpine3.8 as blobber_build
+
+RUN apk add --update --no-cache build-base linux-headers git cmake bash perl grep
+
+# Install Herumi's cryptography
+RUN apk add gmp gmp-dev openssl-dev && \
+    cd /tmp && \
+    wget -O - https://github.com/herumi/mcl/archive/master.tar.gz | tar xz && \
+    wget -O - https://github.com/herumi/bls/archive/master.tar.gz | tar xz && \
+    mv mcl* mcl && \
+    mv bls* bls && \
+    make -C mcl -j $(nproc) lib/libmclbn256.so install && \
+    cp mcl/lib/libmclbn256.so /usr/local/lib && \
+    make -C bls -j $(nproc) install && \
+    rm -R /tmp/mcl && \
+    rm -R /tmp/bls
+
+ENV SRC_DIR=/blobber
+ENV GO111MODULE=on
+
+# Download the dependencies:
+# Will be cached if we don't change mod/sum files
+COPY ./code/go/0chain.net/core/go.mod          ./code/go/0chain.net/core/go.sum          $SRC_DIR/go/0chain.net/core/
+COPY ./code/go/0chain.net/blobbercore/go.mod     ./code/go/0chain.net/blobbercore/go.sum     $SRC_DIR/go/0chain.net/blobbercore/
+COPY ./code/go/0chain.net/blobber/go.mod     ./code/go/0chain.net/blobber/go.sum     $SRC_DIR/go/0chain.net/blobber/
+
+WORKDIR $SRC_DIR/go/0chain.net/blobber
+RUN go mod download
+
+#Add the source code
+ADD ./code/go/0chain.net $SRC_DIR/go/0chain.net
+
+RUN go build -v -tags "bn256 development integration_tests" -ldflags "-X 0chain.net/core/build.BuildTag=$GIT_COMMIT"
+
+# Copy the build artifact into a minimal runtime image:
+FROM golang:1.11.4-alpine3.8
+RUN apk add gmp gmp-dev openssl-dev
+COPY --from=blobber_build  /usr/local/lib/libmcl*.so \
+                        /usr/local/lib/libbls*.so \
+                        /usr/local/lib/
+ENV APP_DIR=/blobber
+WORKDIR $APP_DIR
+COPY --from=blobber_build $APP_DIR/go/0chain.net/blobber/blobber $APP_DIR/bin/blobber
\ No newline at end of file
diff --git a/docker.local/b0docker-compose.yml b/docker.local/b0docker-compose.yml
index c661507..e3949d0 100644
--- a/docker.local/b0docker-compose.yml
+++ b/docker.local/b0docker-compose.yml
@@ -6,6 +6,7 @@ services:
       POSTGRES_PORT: 5432
       POSTGRES_HOST: postgres
       POSTGRES_USER: postgres
+      POSTGRES_PASSWORD: secret
     volumes:
       - ./blobber${BLOBBER}/data/postgresql:/var/lib/postgresql/data
     networks:
@@ -18,6 +19,7 @@ services:
       POSTGRES_PORT: 5432
       POSTGRES_HOST: postgres
       POSTGRES_USER: postgres
+      POSTGRES_PASSWORD: secret
     volumes:
       - ../bin:/blobber/bin
       - ../sql:/blobber/sql
diff --git a/docker.local/bin/blobber.start_bls.sh b/docker.local/bin/blobber.start_bls.sh
index 091c96b..f368657 100755
--- a/docker.local/bin/blobber.start_bls.sh
+++ b/docker.local/bin/blobber.start_bls.sh
@@ -8,4 +8,4 @@ echo Starting blobber$BLOBBER_ID ...
 
 # echo blobber$i
 
-BLOBBER=$BLOBBER_ID docker-compose -p blobber$BLOBBER_ID -f ../b0docker-compose.yml up -d
+BLOBBER=$BLOBBER_ID docker-compose -p blobber$BLOBBER_ID -f ../b0docker-compose.yml up
diff --git a/docker.local/bin/build.bad-blobber.sh b/docker.local/bin/build.bad-blobber.sh
new file mode 100755
index 0000000..130bbde
--- /dev/null
+++ b/docker.local/bin/build.bad-blobber.sh
@@ -0,0 +1,15 @@
+#!/bin/sh
+set -e
+
+GIT_COMMIT=$(git rev-list -1 HEAD)
+echo $GIT_COMMIT
+
+docker build --build-arg GIT_COMMIT=$GIT_COMMIT -f docker.local/ValidatorDockerfile . -t validator
+docker build --build-arg GIT_COMMIT=$GIT_COMMIT -f docker.local/BadBlobberDockerfile . -t blobber
+
+for i in $(seq 1 6);
+do
+  BLOBBER=$i docker-compose -p blobber$i -f docker.local/docker-compose.yml build --force-rm
+done
+
+docker.local/bin/sync_clock.sh
diff --git a/docker.local/bin/docker-clean.sh b/docker.local/bin/docker-clean.sh
new file mode 100755
index 0000000..769f357
--- /dev/null
+++ b/docker.local/bin/docker-clean.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+set -e
+docker-compose                                                \
+    -f ./docker.local/docker-clean/docker-clean-compose.yml   \
+    up                                                        \
+    --build docker-clean
diff --git a/docker.local/docker-clean/Dockerfile b/docker.local/docker-clean/Dockerfile
new file mode 100644
index 0000000..84bc652
--- /dev/null
+++ b/docker.local/docker-clean/Dockerfile
@@ -0,0 +1,7 @@
+
+#
+# clean up blockchain without sudo (as 'docker' system group member)
+#
+
+FROM alpine:latest
+COPY docker-clean.sh ./docker-clean.sh
diff --git a/docker.local/docker-clean/docker-clean-compose.yml b/docker.local/docker-clean/docker-clean-compose.yml
new file mode 100644
index 0000000..afcf1b4
--- /dev/null
+++ b/docker.local/docker-clean/docker-clean-compose.yml
@@ -0,0 +1,23 @@
+version: '3'
+services:
+  docker-clean:
+    build:
+      context: .
+      dockerfile: Dockerfile
+    volumes:
+      # 1-6 blobbers
+      - ../blobber1/:/blobber1
+      - ../blobber2/:/blobber2
+      - ../blobber3/:/blobber3
+      - ../blobber4/:/blobber4
+      - ../blobber5/:/blobber5
+      - ../blobber6/:/blobber6
+    command: /bin/sh docker-clean.sh
+
+volumes:
+  blobber1:
+  blobber2:
+  blobber3:
+  blobber4:
+  blobber5:
+  blobber6:
diff --git a/docker.local/docker-clean/docker-clean.sh b/docker.local/docker-clean/docker-clean.sh
new file mode 100644
index 0000000..aa1255c
--- /dev/null
+++ b/docker.local/docker-clean/docker-clean.sh
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+echo "cleaning 6 blobbers..."
+for i in $(seq 1 6)
+do
+  echo "deleting blobber$i logs"
+  rm -rf ./blobber$i/log/*
+  echo "deleting blobber$i postgresql data"
+  rm -rf ./blobber$i/data/postgresql/*
+  echo "deleting blobber$i files"
+  rm -rf ./blobber$i/data/files/*
+done
+
+echo "cleaned up"
