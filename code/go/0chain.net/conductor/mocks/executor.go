// Code generated by mockery v3.0.0-alpha.0. DO NOT EDIT.

package mocks

import (
	config "0chain.net/conductor/config"
	cases "0chain.net/conductor/config/cases"

	mock "github.com/stretchr/testify/mock"

	stats "0chain.net/conductor/conductrpc/stats"

	time "time"
)

// Executor is an autogenerated mock type for the Executor type
type Executor struct {
	mock.Mock
}

// Challenges provides a mock function with given fields: cs
func (_m *Executor) Challenges(cs *config.Bad) error {
	ret := _m.Called(cs)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(cs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanupBC provides a mock function with given fields: timeout
func (_m *Executor) CleanupBC(timeout time.Duration) error {
	ret := _m.Called(timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = rf(timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Command provides a mock function with given fields: name, timeout
func (_m *Executor) Command(name string, timeout time.Duration) {
	_m.Called(name, timeout)
}

// CompetingBlock provides a mock function with given fields: cb
func (_m *Executor) CompetingBlock(cb *config.Bad) error {
	ret := _m.Called(cb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(cb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConfigureGeneratorsFailure provides a mock function with given fields: round
func (_m *Executor) ConfigureGeneratorsFailure(round config.Round) error {
	ret := _m.Called(round)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.Round) error); ok {
		r0 = rf(round)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConfigureTestCase provides a mock function with given fields: _a0
func (_m *Executor) ConfigureTestCase(_a0 cases.TestCaseConfigurator) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(cases.TestCaseConfigurator) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DoubleSpendTransaction provides a mock function with given fields: dst
func (_m *Executor) DoubleSpendTransaction(dst *config.Bad) error {
	ret := _m.Called(dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EnableClientStatsCollector provides a mock function with given fields:
func (_m *Executor) EnableClientStatsCollector() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EnableServerStatsCollector provides a mock function with given fields:
func (_m *Executor) EnableServerStatsCollector() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExpectActiveSet provides a mock function with given fields: emb
func (_m *Executor) ExpectActiveSet(emb config.ExpectMagicBlock) error {
	ret := _m.Called(emb)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.ExpectMagicBlock) error); ok {
		r0 = rf(emb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FinalizedBlock provides a mock function with given fields: fb
func (_m *Executor) FinalizedBlock(fb *config.Bad) error {
	ret := _m.Called(fb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(fb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetClientStatsCollector provides a mock function with given fields:
func (_m *Executor) GetClientStatsCollector() *stats.NodesClientStats {
	ret := _m.Called()

	var r0 *stats.NodesClientStats
	if rf, ok := ret.Get(0).(func() *stats.NodesClientStats); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stats.NodesClientStats)
		}
	}

	return r0
}

// GetMonitorID provides a mock function with given fields:
func (_m *Executor) GetMonitorID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetServerStatsCollector provides a mock function with given fields:
func (_m *Executor) GetServerStatsCollector() *stats.NodesServerStats {
	ret := _m.Called()

	var r0 *stats.NodesServerStats
	if rf, ok := ret.Get(0).(func() *stats.NodesServerStats); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stats.NodesServerStats)
		}
	}

	return r0
}

// MPK provides a mock function with given fields: mpk
func (_m *Executor) MPK(mpk *config.Bad) error {
	ret := _m.Called(mpk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(mpk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MagicBlock provides a mock function with given fields: mb
func (_m *Executor) MagicBlock(mb *config.Bad) error {
	ret := _m.Called(mb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(mb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MakeTestCaseCheck provides a mock function with given fields: _a0
func (_m *Executor) MakeTestCaseCheck(_a0 *config.TestCaseCheck) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.TestCaseCheck) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MinersNum provides a mock function with given fields:
func (_m *Executor) MinersNum() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// NotarizeOnlyCompetingBlock provides a mock function with given fields: ncb
func (_m *Executor) NotarizeOnlyCompetingBlock(ncb *config.Bad) error {
	ret := _m.Called(ncb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(ncb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotarizedBlock provides a mock function with given fields: nb
func (_m *Executor) NotarizedBlock(nb *config.Bad) error {
	ret := _m.Called(nb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(nb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Publish provides a mock function with given fields: p
func (_m *Executor) Publish(p *config.Bad) error {
	ret := _m.Called(p)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RoundTimeout provides a mock function with given fields: rt
func (_m *Executor) RoundTimeout(rt *config.Bad) error {
	ret := _m.Called(rt)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(rt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveLogs provides a mock function with given fields:
func (_m *Executor) SaveLogs() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetEnv provides a mock function with given fields: _a0
func (_m *Executor) SetEnv(_a0 map[string]string) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]string) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetMagicBlock provides a mock function with given fields: configFile
func (_m *Executor) SetMagicBlock(configFile string) error {
	ret := _m.Called(configFile)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(configFile)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetMonitor provides a mock function with given fields: name
func (_m *Executor) SetMonitor(name config.NodeName) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.NodeName) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetRevealed provides a mock function with given fields: miners, pin, tm
func (_m *Executor) SetRevealed(miners []config.NodeName, pin bool, tm time.Duration) error {
	ret := _m.Called(miners, pin, tm)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, bool, time.Duration) error); ok {
		r0 = rf(miners, pin, tm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetServerState provides a mock function with given fields: _a0
func (_m *Executor) SetServerState(_a0 interface{}) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Shares provides a mock function with given fields: s
func (_m *Executor) Shares(s *config.Bad) error {
	ret := _m.Called(s)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(s)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SignOnlyCompetingBlocks provides a mock function with given fields: socb
func (_m *Executor) SignOnlyCompetingBlocks(socb *config.Bad) error {
	ret := _m.Called(socb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(socb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Signatures provides a mock function with given fields: s
func (_m *Executor) Signatures(s *config.Bad) error {
	ret := _m.Called(s)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(s)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Start provides a mock function with given fields: names, lock, timeout
func (_m *Executor) Start(names []config.NodeName, lock bool, timeout time.Duration) error {
	ret := _m.Called(names, lock, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, bool, time.Duration) error); ok {
		r0 = rf(names, lock, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stop provides a mock function with given fields: names, timeout
func (_m *Executor) Stop(names []config.NodeName, timeout time.Duration) error {
	ret := _m.Called(names, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, time.Duration) error); ok {
		r0 = rf(names, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageTree provides a mock function with given fields: st
func (_m *Executor) StorageTree(st *config.Bad) error {
	ret := _m.Called(st)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(st)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Unlock provides a mock function with given fields: names, timeout
func (_m *Executor) Unlock(names []config.NodeName, timeout time.Duration) error {
	ret := _m.Called(names, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, time.Duration) error); ok {
		r0 = rf(names, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VRFS provides a mock function with given fields: vrfs
func (_m *Executor) VRFS(vrfs *config.Bad) error {
	ret := _m.Called(vrfs)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vrfs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidatorProof provides a mock function with given fields: vp
func (_m *Executor) ValidatorProof(vp *config.Bad) error {
	ret := _m.Called(vp)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerificationTicketGroup provides a mock function with given fields: vtg
func (_m *Executor) VerificationTicketGroup(vtg *config.Bad) error {
	ret := _m.Called(vtg)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vtg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyTransaction provides a mock function with given fields: vt
func (_m *Executor) VerifyTransaction(vt *config.Bad) error {
	ret := _m.Called(vt)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitAdd provides a mock function with given fields: wadd, timeout
func (_m *Executor) WaitAdd(wadd config.WaitAdd, timeout time.Duration) error {
	ret := _m.Called(wadd, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitAdd, time.Duration) error); ok {
		r0 = rf(wadd, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitContributeMpk provides a mock function with given fields: wcmpk, timeout
func (_m *Executor) WaitContributeMpk(wcmpk config.WaitContributeMpk, timeout time.Duration) error {
	ret := _m.Called(wcmpk, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitContributeMpk, time.Duration) error); ok {
		r0 = rf(wcmpk, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitNoProgress provides a mock function with given fields: wait
func (_m *Executor) WaitNoProgress(wait time.Duration) error {
	ret := _m.Called(wait)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = rf(wait)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitNoViewChainge provides a mock function with given fields: wnvc, timeout
func (_m *Executor) WaitNoViewChainge(wnvc config.WaitNoViewChainge, timeout time.Duration) error {
	ret := _m.Called(wnvc, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitNoViewChainge, time.Duration) error); ok {
		r0 = rf(wnvc, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitPhase provides a mock function with given fields: wp, timeout
func (_m *Executor) WaitPhase(wp config.WaitPhase, timeout time.Duration) error {
	ret := _m.Called(wp, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitPhase, time.Duration) error); ok {
		r0 = rf(wp, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitRound provides a mock function with given fields: wr, timeout
func (_m *Executor) WaitRound(wr config.WaitRound, timeout time.Duration) error {
	ret := _m.Called(wr, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitRound, time.Duration) error); ok {
		r0 = rf(wr, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitSharderKeep provides a mock function with given fields: wsk, timeout
func (_m *Executor) WaitSharderKeep(wsk config.WaitSharderKeep, timeout time.Duration) error {
	ret := _m.Called(wsk, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitSharderKeep, time.Duration) error); ok {
		r0 = rf(wsk, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitShareSignsOrShares provides a mock function with given fields: ssos, timeout
func (_m *Executor) WaitShareSignsOrShares(ssos config.WaitShareSignsOrShares, timeout time.Duration) error {
	ret := _m.Called(ssos, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitShareSignsOrShares, time.Duration) error); ok {
		r0 = rf(ssos, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitViewChange provides a mock function with given fields: vc, timeout
func (_m *Executor) WaitViewChange(vc config.WaitViewChange, timeout time.Duration) error {
	ret := _m.Called(vc, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitViewChange, time.Duration) error); ok {
		r0 = rf(vc, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockDDoS provides a mock function with given fields: wb
func (_m *Executor) WrongBlockDDoS(wb *config.Bad) error {
	ret := _m.Called(wb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockHash provides a mock function with given fields: wbh
func (_m *Executor) WrongBlockHash(wbh *config.Bad) error {
	ret := _m.Called(wbh)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wbh)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockRandomSeed provides a mock function with given fields: wb
func (_m *Executor) WrongBlockRandomSeed(wb *config.Bad) error {
	ret := _m.Called(wb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockSignHash provides a mock function with given fields: wbsh
func (_m *Executor) WrongBlockSignHash(wbsh *config.Bad) error {
	ret := _m.Called(wbsh)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wbsh)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockSignKey provides a mock function with given fields: wbsk
func (_m *Executor) WrongBlockSignKey(wbsk *config.Bad) error {
	ret := _m.Called(wbsk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wbsk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongNotarizedBlockHash provides a mock function with given fields: wnbh
func (_m *Executor) WrongNotarizedBlockHash(wnbh *config.Bad) error {
	ret := _m.Called(wnbh)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wnbh)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongNotarizedBlockKey provides a mock function with given fields: wnbk
func (_m *Executor) WrongNotarizedBlockKey(wnbk *config.Bad) error {
	ret := _m.Called(wnbk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wnbk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongVerificationTicketHash provides a mock function with given fields: wvth
func (_m *Executor) WrongVerificationTicketHash(wvth *config.Bad) error {
	ret := _m.Called(wvth)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wvth)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongVerificationTicketKey provides a mock function with given fields: wvtk
func (_m *Executor) WrongVerificationTicketKey(wvtk *config.Bad) error {
	ret := _m.Called(wvtk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wvtk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewExecutor interface {
	mock.TestingT
	Cleanup(func())
}

// NewExecutor creates a new instance of Executor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewExecutor(t mockConstructorTestingTNewExecutor) *Executor {
	mock := &Executor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
