// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	block "0chain.net/chaincore/block"
	mock "github.com/stretchr/testify/mock"

	node "0chain.net/chaincore/node"

	round "0chain.net/chaincore/round"
)

// RoundI is an autogenerated mock type for the RoundI type
type RoundI struct {
	mock.Mock
}

// AddNotarizedBlock provides a mock function with given fields: b
func (_m *RoundI) AddNotarizedBlock(b *block.Block) (*block.Block, bool) {
	ret := _m.Called(b)

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func(*block.Block) *block.Block); ok {
		r0 = rf(b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(*block.Block) bool); ok {
		r1 = rf(b)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// AddProposedBlock provides a mock function with given fields: b
func (_m *RoundI) AddProposedBlock(b *block.Block) (*block.Block, bool) {
	ret := _m.Called(b)

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func(*block.Block) *block.Block); ok {
		r0 = rf(b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(*block.Block) bool); ok {
		r1 = rf(b)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// AddVRFShare provides a mock function with given fields: share, threshold
func (_m *RoundI) AddVRFShare(share *round.VRFShare, threshold int) bool {
	ret := _m.Called(share, threshold)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*round.VRFShare, int) bool); ok {
		r0 = rf(share, threshold)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Clear provides a mock function with given fields:
func (_m *RoundI) Clear() {
	_m.Called()
}

// Finalize provides a mock function with given fields: b
func (_m *RoundI) Finalize(b *block.Block) {
	_m.Called(b)
}

// GetBestRankedNotarizedBlock provides a mock function with given fields:
func (_m *RoundI) GetBestRankedNotarizedBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetHeaviestNotarizedBlock provides a mock function with given fields:
func (_m *RoundI) GetHeaviestNotarizedBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetMinerRank provides a mock function with given fields: miner
func (_m *RoundI) GetMinerRank(miner *node.Node) int {
	ret := _m.Called(miner)

	var r0 int
	if rf, ok := ret.Get(0).(func(*node.Node) int); ok {
		r0 = rf(miner)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetMinersByRank provides a mock function with given fields: miners
func (_m *RoundI) GetMinersByRank(miners *node.Pool) []*node.Node {
	ret := _m.Called(miners)

	var r0 []*node.Node
	if rf, ok := ret.Get(0).(func(*node.Pool) []*node.Node); ok {
		r0 = rf(miners)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*node.Node)
		}
	}

	return r0
}

// GetNotarizedBlocks provides a mock function with given fields:
func (_m *RoundI) GetNotarizedBlocks() []*block.Block {
	ret := _m.Called()

	var r0 []*block.Block
	if rf, ok := ret.Get(0).(func() []*block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*block.Block)
		}
	}

	return r0
}

// GetProposedBlocks provides a mock function with given fields:
func (_m *RoundI) GetProposedBlocks() []*block.Block {
	ret := _m.Called()

	var r0 []*block.Block
	if rf, ok := ret.Get(0).(func() []*block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*block.Block)
		}
	}

	return r0
}

// GetRandomSeed provides a mock function with given fields:
func (_m *RoundI) GetRandomSeed() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GetRoundNumber provides a mock function with given fields:
func (_m *RoundI) GetRoundNumber() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GetState provides a mock function with given fields:
func (_m *RoundI) GetState() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetTimeoutCount provides a mock function with given fields:
func (_m *RoundI) GetTimeoutCount() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetVRFShares provides a mock function with given fields:
func (_m *RoundI) GetVRFShares() map[string]*round.VRFShare {
	ret := _m.Called()

	var r0 map[string]*round.VRFShare
	if rf, ok := ret.Get(0).(func() map[string]*round.VRFShare); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*round.VRFShare)
		}
	}

	return r0
}

// HasRandomSeed provides a mock function with given fields:
func (_m *RoundI) HasRandomSeed() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsFinalized provides a mock function with given fields:
func (_m *RoundI) IsFinalized() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsFinalizing provides a mock function with given fields:
func (_m *RoundI) IsFinalizing() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsRanksComputed provides a mock function with given fields:
func (_m *RoundI) IsRanksComputed() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SetFinalizing provides a mock function with given fields:
func (_m *RoundI) SetFinalizing() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SetRandomSeed provides a mock function with given fields: seed, minersNum
func (_m *RoundI) SetRandomSeed(seed int64, minersNum int) {
	_m.Called(seed, minersNum)
}

// SetRandomSeedForNotarizedBlock provides a mock function with given fields: seed, minersNum
func (_m *RoundI) SetRandomSeedForNotarizedBlock(seed int64, minersNum int) {
	_m.Called(seed, minersNum)
}

// SetState provides a mock function with given fields: state
func (_m *RoundI) SetState(state int) {
	_m.Called(state)
}

// SetTimeoutCount provides a mock function with given fields: tc
func (_m *RoundI) SetTimeoutCount(tc int) bool {
	ret := _m.Called(tc)

	var r0 bool
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(tc)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}
