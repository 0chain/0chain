// Code generated by mockery v2.6.0. DO NOT EDIT.

package persistencestore

import (
	gocql "github.com/gocql/gocql"
	mock "github.com/stretchr/testify/mock"

	persistencestore "0chain.net/core/persistencestore"
)

// SessionI is an autogenerated mock type for the SessionI type
type SessionI struct {
	mock.Mock
}

// Bind provides a mock function with given fields: stmt, b
func (_m *SessionI) Bind(stmt string, b func(*gocql.QueryInfo) ([]interface{}, error)) persistencestore.QueryI {
	ret := _m.Called(stmt, b)

	var r0 persistencestore.QueryI
	if rf, ok := ret.Get(0).(func(string, func(*gocql.QueryInfo) ([]interface{}, error)) persistencestore.QueryI); ok {
		r0 = rf(stmt, b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(persistencestore.QueryI)
		}
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *SessionI) Close() {
	_m.Called()
}

// Closed provides a mock function with given fields:
func (_m *SessionI) Closed() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ExecuteBatch provides a mock function with given fields: batch
func (_m *SessionI) ExecuteBatch(batch persistencestore.BatchI) error {
	ret := _m.Called(batch)

	var r0 error
	if rf, ok := ret.Get(0).(func(persistencestore.BatchI) error); ok {
		r0 = rf(batch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteBatchCAS provides a mock function with given fields: batch, dest
func (_m *SessionI) ExecuteBatchCAS(batch *gocql.Batch, dest ...interface{}) (bool, *gocql.Iter, error) {
	var _ca []interface{}
	_ca = append(_ca, batch)
	_ca = append(_ca, dest...)
	ret := _m.Called(_ca...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*gocql.Batch, ...interface{}) bool); ok {
		r0 = rf(batch, dest...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 *gocql.Iter
	if rf, ok := ret.Get(1).(func(*gocql.Batch, ...interface{}) *gocql.Iter); ok {
		r1 = rf(batch, dest...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gocql.Iter)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*gocql.Batch, ...interface{}) error); ok {
		r2 = rf(batch, dest...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// KeyspaceMetadata provides a mock function with given fields: keyspace
func (_m *SessionI) KeyspaceMetadata(keyspace string) (*gocql.KeyspaceMetadata, error) {
	ret := _m.Called(keyspace)

	var r0 *gocql.KeyspaceMetadata
	if rf, ok := ret.Get(0).(func(string) *gocql.KeyspaceMetadata); ok {
		r0 = rf(keyspace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocql.KeyspaceMetadata)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(keyspace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MapExecuteBatchCAS provides a mock function with given fields: batch, dest
func (_m *SessionI) MapExecuteBatchCAS(batch *gocql.Batch, dest map[string]interface{}) (bool, *gocql.Iter, error) {
	ret := _m.Called(batch, dest)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*gocql.Batch, map[string]interface{}) bool); ok {
		r0 = rf(batch, dest)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 *gocql.Iter
	if rf, ok := ret.Get(1).(func(*gocql.Batch, map[string]interface{}) *gocql.Iter); ok {
		r1 = rf(batch, dest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gocql.Iter)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*gocql.Batch, map[string]interface{}) error); ok {
		r2 = rf(batch, dest)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NewBatch provides a mock function with given fields: _a0
func (_m *SessionI) NewBatch(_a0 gocql.BatchType) persistencestore.BatchI {
	ret := _m.Called(_a0)

	var r0 persistencestore.BatchI
	if rf, ok := ret.Get(0).(func(gocql.BatchType) persistencestore.BatchI); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(persistencestore.BatchI)
		}
	}

	return r0
}

// Query provides a mock function with given fields: stmt, values
func (_m *SessionI) Query(stmt string, values ...interface{}) persistencestore.QueryI {
	var _ca []interface{}
	_ca = append(_ca, stmt)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 persistencestore.QueryI
	if rf, ok := ret.Get(0).(func(string, ...interface{}) persistencestore.QueryI); ok {
		r0 = rf(stmt, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(persistencestore.QueryI)
		}
	}

	return r0
}

// SetConsistency provides a mock function with given fields: cons
func (_m *SessionI) SetConsistency(cons gocql.Consistency) {
	_m.Called(cons)
}

// SetPageSize provides a mock function with given fields: n
func (_m *SessionI) SetPageSize(n int) {
	_m.Called(n)
}

// SetPrefetch provides a mock function with given fields: p
func (_m *SessionI) SetPrefetch(p float64) {
	_m.Called(p)
}

// SetTrace provides a mock function with given fields: trace
func (_m *SessionI) SetTrace(trace gocql.Tracer) {
	_m.Called(trace)
}
