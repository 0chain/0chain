// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	config "0chain.net/conductor/config"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// Executor is an autogenerated mock type for the Executor type
type Executor struct {
	mock.Mock
}

// Challenges provides a mock function with given fields: cs
func (_m *Executor) Challenges(cs *config.Bad) error {
	ret := _m.Called(cs)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(cs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanupBC provides a mock function with given fields: timeout
func (_m *Executor) CleanupBC(timeout time.Duration) error {
	ret := _m.Called(timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = rf(timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Command provides a mock function with given fields: name, timeout
func (_m *Executor) Command(name string, timeout time.Duration) {
	_m.Called(name, timeout)
}

// CompetingBlock provides a mock function with given fields: cb
func (_m *Executor) CompetingBlock(cb *config.Bad) error {
	ret := _m.Called(cb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(cb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DoubleSpendTransaction provides a mock function with given fields: dst
func (_m *Executor) DoubleSpendTransaction(dst *config.Bad) error {
	ret := _m.Called(dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FinalizedBlock provides a mock function with given fields: fb
func (_m *Executor) FinalizedBlock(fb *config.Bad) error {
	ret := _m.Called(fb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(fb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MPK provides a mock function with given fields: mpk
func (_m *Executor) MPK(mpk *config.Bad) error {
	ret := _m.Called(mpk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(mpk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MagicBlock provides a mock function with given fields: mb
func (_m *Executor) MagicBlock(mb *config.Bad) error {
	ret := _m.Called(mb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(mb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotarizeOnlyCompetingBlock provides a mock function with given fields: ncb
func (_m *Executor) NotarizeOnlyCompetingBlock(ncb *config.Bad) error {
	ret := _m.Called(ncb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(ncb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotarizedBlock provides a mock function with given fields: nb
func (_m *Executor) NotarizedBlock(nb *config.Bad) error {
	ret := _m.Called(nb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(nb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Publish provides a mock function with given fields: p
func (_m *Executor) Publish(p *config.Bad) error {
	ret := _m.Called(p)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RoundTimeout provides a mock function with given fields: rt
func (_m *Executor) RoundTimeout(rt *config.Bad) error {
	ret := _m.Called(rt)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(rt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetMonitor provides a mock function with given fields: name
func (_m *Executor) SetMonitor(name config.NodeName) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.NodeName) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetRevealed provides a mock function with given fields: miners, pin, tm
func (_m *Executor) SetRevealed(miners []config.NodeName, pin bool, tm time.Duration) error {
	ret := _m.Called(miners, pin, tm)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, bool, time.Duration) error); ok {
		r0 = rf(miners, pin, tm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Shares provides a mock function with given fields: s
func (_m *Executor) Shares(s *config.Bad) error {
	ret := _m.Called(s)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(s)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SignOnlyCompetingBlocks provides a mock function with given fields: socb
func (_m *Executor) SignOnlyCompetingBlocks(socb *config.Bad) error {
	ret := _m.Called(socb)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(socb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Signatures provides a mock function with given fields: s
func (_m *Executor) Signatures(s *config.Bad) error {
	ret := _m.Called(s)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(s)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Start provides a mock function with given fields: names, lock, timeout
func (_m *Executor) Start(names []config.NodeName, lock bool, timeout time.Duration) error {
	ret := _m.Called(names, lock, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, bool, time.Duration) error); ok {
		r0 = rf(names, lock, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stop provides a mock function with given fields: names, timeout
func (_m *Executor) Stop(names []config.NodeName, timeout time.Duration) error {
	ret := _m.Called(names, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, time.Duration) error); ok {
		r0 = rf(names, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StorageTree provides a mock function with given fields: st
func (_m *Executor) StorageTree(st *config.Bad) error {
	ret := _m.Called(st)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(st)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Unlock provides a mock function with given fields: names, timeout
func (_m *Executor) Unlock(names []config.NodeName, timeout time.Duration) error {
	ret := _m.Called(names, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func([]config.NodeName, time.Duration) error); ok {
		r0 = rf(names, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VRFS provides a mock function with given fields: vrfs
func (_m *Executor) VRFS(vrfs *config.Bad) error {
	ret := _m.Called(vrfs)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vrfs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidatorProof provides a mock function with given fields: vp
func (_m *Executor) ValidatorProof(vp *config.Bad) error {
	ret := _m.Called(vp)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerificationTicketGroup provides a mock function with given fields: vtg
func (_m *Executor) VerificationTicketGroup(vtg *config.Bad) error {
	ret := _m.Called(vtg)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vtg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyTransaction provides a mock function with given fields: vt
func (_m *Executor) VerifyTransaction(vt *config.Bad) error {
	ret := _m.Called(vt)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(vt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitAdd provides a mock function with given fields: wadd, timeout
func (_m *Executor) WaitAdd(wadd config.WaitAdd, timeout time.Duration) error {
	ret := _m.Called(wadd, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitAdd, time.Duration) error); ok {
		r0 = rf(wadd, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitContributeMpk provides a mock function with given fields: wcmpk, timeout
func (_m *Executor) WaitContributeMpk(wcmpk config.WaitContributeMpk, timeout time.Duration) error {
	ret := _m.Called(wcmpk, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitContributeMpk, time.Duration) error); ok {
		r0 = rf(wcmpk, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitNoProgress provides a mock function with given fields: wait
func (_m *Executor) WaitNoProgress(wait time.Duration) error {
	ret := _m.Called(wait)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = rf(wait)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitNoViewChainge provides a mock function with given fields: wnvc, timeout
func (_m *Executor) WaitNoViewChainge(wnvc config.WaitNoViewChainge, timeout time.Duration) error {
	ret := _m.Called(wnvc, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitNoViewChainge, time.Duration) error); ok {
		r0 = rf(wnvc, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitPhase provides a mock function with given fields: wp, timeout
func (_m *Executor) WaitPhase(wp config.WaitPhase, timeout time.Duration) error {
	ret := _m.Called(wp, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitPhase, time.Duration) error); ok {
		r0 = rf(wp, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitRound provides a mock function with given fields: wr, timeout
func (_m *Executor) WaitRound(wr config.WaitRound, timeout time.Duration) error {
	ret := _m.Called(wr, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitRound, time.Duration) error); ok {
		r0 = rf(wr, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitSharderKeep provides a mock function with given fields: wsk, timeout
func (_m *Executor) WaitSharderKeep(wsk config.WaitSharderKeep, timeout time.Duration) error {
	ret := _m.Called(wsk, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitSharderKeep, time.Duration) error); ok {
		r0 = rf(wsk, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitShareSignsOrShares provides a mock function with given fields: ssos, timeout
func (_m *Executor) WaitShareSignsOrShares(ssos config.WaitShareSignsOrShares, timeout time.Duration) error {
	ret := _m.Called(ssos, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitShareSignsOrShares, time.Duration) error); ok {
		r0 = rf(ssos, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitViewChange provides a mock function with given fields: vc, timeout
func (_m *Executor) WaitViewChange(vc config.WaitViewChange, timeout time.Duration) error {
	ret := _m.Called(vc, timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(config.WaitViewChange, time.Duration) error); ok {
		r0 = rf(vc, timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockHash provides a mock function with given fields: wbh
func (_m *Executor) WrongBlockHash(wbh *config.Bad) error {
	ret := _m.Called(wbh)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wbh)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockSignHash provides a mock function with given fields: wbsh
func (_m *Executor) WrongBlockSignHash(wbsh *config.Bad) error {
	ret := _m.Called(wbsh)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wbsh)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongBlockSignKey provides a mock function with given fields: wbsk
func (_m *Executor) WrongBlockSignKey(wbsk *config.Bad) error {
	ret := _m.Called(wbsk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wbsk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongNotarizedBlockHash provides a mock function with given fields: wnbh
func (_m *Executor) WrongNotarizedBlockHash(wnbh *config.Bad) error {
	ret := _m.Called(wnbh)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wnbh)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongNotarizedBlockKey provides a mock function with given fields: wnbk
func (_m *Executor) WrongNotarizedBlockKey(wnbk *config.Bad) error {
	ret := _m.Called(wnbk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wnbk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongVerificationTicketHash provides a mock function with given fields: wvth
func (_m *Executor) WrongVerificationTicketHash(wvth *config.Bad) error {
	ret := _m.Called(wvth)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wvth)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WrongVerificationTicketKey provides a mock function with given fields: wvtk
func (_m *Executor) WrongVerificationTicketKey(wvtk *config.Bad) error {
	ret := _m.Called(wvtk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*config.Bad) error); ok {
		r0 = rf(wvtk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
