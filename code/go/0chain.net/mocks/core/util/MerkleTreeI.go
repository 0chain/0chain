// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	util "0chain.net/core/util"
	mock "github.com/stretchr/testify/mock"
)

// MerkleTreeI is an autogenerated mock type for the MerkleTreeI type
type MerkleTreeI struct {
	mock.Mock
}

// ComputeTree provides a mock function with given fields: hashes
func (_m *MerkleTreeI) ComputeTree(hashes []util.Hashable) {
	_m.Called(hashes)
}

// GetPath provides a mock function with given fields: hash
func (_m *MerkleTreeI) GetPath(hash util.Hashable) *util.MTPath {
	ret := _m.Called(hash)

	var r0 *util.MTPath
	if rf, ok := ret.Get(0).(func(util.Hashable) *util.MTPath); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*util.MTPath)
		}
	}

	return r0
}

// GetPathByIndex provides a mock function with given fields: idx
func (_m *MerkleTreeI) GetPathByIndex(idx int) *util.MTPath {
	ret := _m.Called(idx)

	var r0 *util.MTPath
	if rf, ok := ret.Get(0).(func(int) *util.MTPath); ok {
		r0 = rf(idx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*util.MTPath)
		}
	}

	return r0
}

// GetRoot provides a mock function with given fields:
func (_m *MerkleTreeI) GetRoot() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetTree provides a mock function with given fields:
func (_m *MerkleTreeI) GetTree() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// SetTree provides a mock function with given fields: leavesCount, tree
func (_m *MerkleTreeI) SetTree(leavesCount int, tree []string) error {
	ret := _m.Called(leavesCount, tree)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, []string) error); ok {
		r0 = rf(leavesCount, tree)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyPath provides a mock function with given fields: hash, path
func (_m *MerkleTreeI) VerifyPath(hash util.Hashable, path *util.MTPath) bool {
	ret := _m.Called(hash, path)

	var r0 bool
	if rf, ok := ret.Get(0).(func(util.Hashable, *util.MTPath) bool); ok {
		r0 = rf(hash, path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}
