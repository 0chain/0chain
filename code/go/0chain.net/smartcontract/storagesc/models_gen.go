package storagesc

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *AllocBlobber) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "bid"
	o = append(o, 0x83, 0xa3, 0x62, 0x69, 0x64)
	o = msgp.AppendString(o, z.BlobberID)
	// string "m"
	o = append(o, 0xa1, 0x6d)
	o, err = z.MinLockDemand.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MinLockDemand")
		return
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	// map header, size 3
	// string "ReadPrice"
	o = append(o, 0x83, 0xa9, 0x52, 0x65, 0x61, 0x64, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.Terms.ReadPrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Terms", "ReadPrice")
		return
	}
	// string "WritePrice"
	o = append(o, 0xaa, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.Terms.WritePrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Terms", "WritePrice")
		return
	}
	// string "MinLockDemand"
	o = append(o, 0xad, 0x4d, 0x69, 0x6e, 0x4c, 0x6f, 0x63, 0x6b, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.Terms.MinLockDemand)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AllocBlobber) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bid":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "m":
			bts, err = z.MinLockDemand.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinLockDemand")
				return
			}
		case "t":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Terms")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Terms")
					return
				}
				switch msgp.UnsafeString(field) {
				case "ReadPrice":
					bts, err = z.Terms.ReadPrice.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms", "ReadPrice")
						return
					}
				case "WritePrice":
					bts, err = z.Terms.WritePrice.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms", "WritePrice")
						return
					}
				case "MinLockDemand":
					z.Terms.MinLockDemand, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms", "MinLockDemand")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AllocBlobber) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.BlobberID) + 2 + z.MinLockDemand.Msgsize() + 2 + 1 + 10 + z.Terms.ReadPrice.Msgsize() + 11 + z.Terms.WritePrice.Msgsize() + 14 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AllocOpenChallenge) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "ID"
	o = append(o, 0x83, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "CreatedAt"
	o = append(o, 0xa9, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74)
	o, err = z.CreatedAt.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "CreatedAt")
		return
	}
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AllocOpenChallenge) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "CreatedAt":
			bts, err = z.CreatedAt.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AllocOpenChallenge) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 10 + z.CreatedAt.Msgsize() + 10 + msgp.StringPrefixSize + len(z.BlobberID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Allocations) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "List"
	o = append(o, 0x81, 0xa4, 0x4c, 0x69, 0x73, 0x74)
	o, err = z.List.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "List")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Allocations) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "List":
			bts, err = z.List.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "List")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Allocations) Msgsize() (s int) {
	s = 1 + 5 + z.List.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BlobberAllocation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "s"
	o = append(o, 0x8a, 0xa1, 0x73)
	o, err = z.Spent.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Spent")
		return
	}
	// string "p"
	o = append(o, 0xa1, 0x70)
	o, err = z.Penalty.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Penalty")
		return
	}
	// string "rr"
	o = append(o, 0xa2, 0x72, 0x72)
	o, err = z.ReadReward.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadReward")
		return
	}
	// string "r"
	o = append(o, 0xa1, 0x72)
	o, err = z.Returned.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Returned")
		return
	}
	// string "cr"
	o = append(o, 0xa2, 0x63, 0x72)
	o, err = z.ChallengeReward.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ChallengeReward")
		return
	}
	// string "cpi"
	o = append(o, 0xa3, 0x63, 0x70, 0x69)
	o, err = z.ChallengePoolIntegralValue.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ChallengePoolIntegralValue")
		return
	}
	// string "sts"
	o = append(o, 0xa3, 0x73, 0x74, 0x73)
	if z.Stats == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Stats.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Stats")
			return
		}
	}
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BlobberID)
	// string "ar"
	o = append(o, 0xa2, 0x61, 0x72)
	o = msgp.AppendString(o, z.AllocationRoot)
	// string "wm"
	o = append(o, 0xa2, 0x77, 0x6d)
	if z.LastWriteMarker == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.LastWriteMarker.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LastWriteMarker")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlobberAllocation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			bts, err = z.Spent.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spent")
				return
			}
		case "p":
			bts, err = z.Penalty.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Penalty")
				return
			}
		case "rr":
			bts, err = z.ReadReward.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadReward")
				return
			}
		case "r":
			bts, err = z.Returned.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Returned")
				return
			}
		case "cr":
			bts, err = z.ChallengeReward.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengeReward")
				return
			}
		case "cpi":
			bts, err = z.ChallengePoolIntegralValue.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengePoolIntegralValue")
				return
			}
		case "sts":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Stats = nil
			} else {
				if z.Stats == nil {
					z.Stats = new(StorageAllocationStats)
				}
				bts, err = z.Stats.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stats")
					return
				}
			}
		case "b":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "ar":
			z.AllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationRoot")
				return
			}
		case "wm":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastWriteMarker = nil
			} else {
				if z.LastWriteMarker == nil {
					z.LastWriteMarker = new(WriteMarker)
				}
				bts, err = z.LastWriteMarker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastWriteMarker")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlobberAllocation) Msgsize() (s int) {
	s = 1 + 2 + z.Spent.Msgsize() + 2 + z.Penalty.Msgsize() + 3 + z.ReadReward.Msgsize() + 2 + z.Returned.Msgsize() + 3 + z.ChallengeReward.Msgsize() + 4 + z.ChallengePoolIntegralValue.Msgsize() + 4
	if z.Stats == nil {
		s += msgp.NilSize
	} else {
		s += z.Stats.Msgsize()
	}
	s += 2 + msgp.StringPrefixSize + len(z.BlobberID) + 3 + msgp.StringPrefixSize + len(z.AllocationRoot) + 3
	if z.LastWriteMarker == nil {
		s += msgp.NilSize
	} else {
		s += z.LastWriteMarker.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BlobberCloseConnection) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "AllocationRoot"
	o = append(o, 0x83, 0xae, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.AllocationRoot)
	// string "PrevAllocationRoot"
	o = append(o, 0xb2, 0x50, 0x72, 0x65, 0x76, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.PrevAllocationRoot)
	// string "WriteMarker"
	o = append(o, 0xab, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72)
	if z.WriteMarker == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.WriteMarker.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "WriteMarker")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlobberCloseConnection) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AllocationRoot":
			z.AllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationRoot")
				return
			}
		case "PrevAllocationRoot":
			z.PrevAllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PrevAllocationRoot")
				return
			}
		case "WriteMarker":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.WriteMarker = nil
			} else {
				if z.WriteMarker == nil {
					z.WriteMarker = new(WriteMarker)
				}
				bts, err = z.WriteMarker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "WriteMarker")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlobberCloseConnection) Msgsize() (s int) {
	s = 1 + 15 + msgp.StringPrefixSize + len(z.AllocationRoot) + 19 + msgp.StringPrefixSize + len(z.PrevAllocationRoot) + 12
	if z.WriteMarker == nil {
		s += msgp.NilSize
	} else {
		s += z.WriteMarker.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChallengeResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "ID"
	o = append(o, 0x82, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "ValidationTickets"
	o = append(o, 0xb1, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ValidationTickets)))
	for za0001 := range z.ValidationTickets {
		if z.ValidationTickets[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.ValidationTickets[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ValidationTickets", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChallengeResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ValidationTickets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidationTickets")
				return
			}
			if cap(z.ValidationTickets) >= int(zb0002) {
				z.ValidationTickets = (z.ValidationTickets)[:zb0002]
			} else {
				z.ValidationTickets = make([]*ValidationTicket, zb0002)
			}
			for za0001 := range z.ValidationTickets {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.ValidationTickets[za0001] = nil
				} else {
					if z.ValidationTickets[za0001] == nil {
						z.ValidationTickets[za0001] = new(ValidationTicket)
					}
					bts, err = z.ValidationTickets[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ValidationTickets", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChallengeResponse) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 18 + msgp.ArrayHeaderSize
	for za0001 := range z.ValidationTickets {
		if z.ValidationTickets[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.ValidationTickets[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Info) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Name"
	o = append(o, 0x84, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "WebsiteUrl"
	o = append(o, 0xaa, 0x57, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x55, 0x72, 0x6c)
	o = msgp.AppendString(o, z.WebsiteUrl)
	// string "LogoUrl"
	o = append(o, 0xa7, 0x4c, 0x6f, 0x67, 0x6f, 0x55, 0x72, 0x6c)
	o = msgp.AppendString(o, z.LogoUrl)
	// string "Description"
	o = append(o, 0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Info) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "WebsiteUrl":
			z.WebsiteUrl, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WebsiteUrl")
				return
			}
		case "LogoUrl":
			z.LogoUrl, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LogoUrl")
				return
			}
		case "Description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Info) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 11 + msgp.StringPrefixSize + len(z.WebsiteUrl) + 8 + msgp.StringPrefixSize + len(z.LogoUrl) + 12 + msgp.StringPrefixSize + len(z.Description)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PriceRange) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Min"
	o = append(o, 0x82, 0xa3, 0x4d, 0x69, 0x6e)
	o, err = z.Min.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o, err = z.Max.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PriceRange) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Min":
			bts, err = z.Min.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
		case "Max":
			bts, err = z.Max.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PriceRange) Msgsize() (s int) {
	s = 1 + 4 + z.Min.Msgsize() + 4 + z.Max.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReadConnection) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "ReadMarker"
	o = append(o, 0x81, 0xaa, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72)
	if z.ReadMarker == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ReadMarker.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ReadMarker")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadConnection) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ReadMarker":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ReadMarker = nil
			} else {
				if z.ReadMarker == nil {
					z.ReadMarker = new(ReadMarker)
				}
				bts, err = z.ReadMarker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReadMarker")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReadConnection) Msgsize() (s int) {
	s = 1 + 11
	if z.ReadMarker == nil {
		s += msgp.NilSize
	} else {
		s += z.ReadMarker.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReadMarker) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "ClientID"
	o = append(o, 0x89, 0xa8, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44)
	o = msgp.AppendString(o, z.ClientID)
	// string "ClientPublicKey"
	o = append(o, 0xaf, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.ClientPublicKey)
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	// string "AllocationID"
	o = append(o, 0xac, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.AllocationID)
	// string "OwnerID"
	o = append(o, 0xa7, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.OwnerID)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// string "ReadCounter"
	o = append(o, 0xab, 0x52, 0x65, 0x61, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72)
	o = msgp.AppendInt64(o, z.ReadCounter)
	// string "Signature"
	o = append(o, 0xa9, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65)
	o = msgp.AppendString(o, z.Signature)
	// string "ReadSize"
	o = append(o, 0xa8, 0x52, 0x65, 0x61, 0x64, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendFloat64(o, z.ReadSize)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadMarker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ClientID":
			z.ClientID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "ClientPublicKey":
			z.ClientPublicKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientPublicKey")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "AllocationID":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "OwnerID":
			z.OwnerID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OwnerID")
				return
			}
		case "Timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "ReadCounter":
			z.ReadCounter, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadCounter")
				return
			}
		case "Signature":
			z.Signature, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		case "ReadSize":
			z.ReadSize, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadSize")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReadMarker) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.ClientID) + 16 + msgp.StringPrefixSize + len(z.ClientPublicKey) + 10 + msgp.StringPrefixSize + len(z.BlobberID) + 13 + msgp.StringPrefixSize + len(z.AllocationID) + 8 + msgp.StringPrefixSize + len(z.OwnerID) + 10 + z.Timestamp.Msgsize() + 12 + msgp.Int64Size + 10 + msgp.StringPrefixSize + len(z.Signature) + 9 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RewardRound) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "StartRound"
	o = append(o, 0x82, 0xaa, 0x53, 0x74, 0x61, 0x72, 0x74, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendInt64(o, z.StartRound)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RewardRound) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "StartRound":
			z.StartRound, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartRound")
				return
			}
		case "Timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RewardRound) Msgsize() (s int) {
	s = 1 + 11 + msgp.Int64Size + 10 + z.Timestamp.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageAllocationDecode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 26
	// string "fo"
	o = append(o, 0xde, 0x0, 0x1a, 0xa2, 0x66, 0x6f)
	o = msgp.AppendUint16(o, z.FileOptions)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendInt(o, z.DataShards)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendInt(o, z.ParityShards)
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendInt64(o, z.Size)
	// string "bz"
	o = append(o, 0xa2, 0x62, 0x7a)
	o = msgp.AppendInt64(o, z.BSize)
	// string "rp"
	o = append(o, 0xa2, 0x72, 0x70)
	// map header, size 2
	// string "Min"
	o = append(o, 0x82, 0xa3, 0x4d, 0x69, 0x6e)
	o, err = z.ReadPriceRange.Min.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadPriceRange", "Min")
		return
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o, err = z.ReadPriceRange.Max.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadPriceRange", "Max")
		return
	}
	// string "wp"
	o = append(o, 0xa2, 0x77, 0x70)
	// map header, size 2
	// string "Min"
	o = append(o, 0x82, 0xa3, 0x4d, 0x69, 0x6e)
	o, err = z.WritePriceRange.Min.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePriceRange", "Min")
		return
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o, err = z.WritePriceRange.Max.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePriceRange", "Max")
		return
	}
	// string "tpe"
	o = append(o, 0xa3, 0x74, 0x70, 0x65)
	o = msgp.AppendBool(o, z.ThirdPartyExtendable)
	// string "f"
	o = append(o, 0xa1, 0x66)
	o = msgp.AppendBool(o, z.Finalized)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendBool(o, z.Canceled)
	// string "w"
	o = append(o, 0xa1, 0x77)
	o, err = z.WritePool.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePool")
		return
	}
	// string "cp"
	o = append(o, 0xa2, 0x63, 0x70)
	o, err = z.ChallengePool.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ChallengePool")
		return
	}
	// string "mtc"
	o = append(o, 0xa3, 0x6d, 0x74, 0x63)
	o, err = z.MovedToChallenge.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MovedToChallenge")
		return
	}
	// string "mb"
	o = append(o, 0xa2, 0x6d, 0x62)
	o, err = z.MovedBack.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MovedBack")
		return
	}
	// string "mv"
	o = append(o, 0xa2, 0x6d, 0x76)
	o, err = z.MovedToValidators.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MovedToValidators")
		return
	}
	// string "cc"
	o = append(o, 0xa2, 0x63, 0x63)
	o, err = z.CancelCost.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "CancelCost")
		return
	}
	// string "ep"
	o = append(o, 0xa2, 0x65, 0x70)
	o, err = z.Expiration.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Expiration")
		return
	}
	// string "st"
	o = append(o, 0xa2, 0x73, 0x74)
	o, err = z.StartTime.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// string "tu"
	o = append(o, 0xa2, 0x74, 0x75)
	o = msgp.AppendDuration(o, z.TimeUnit)
	// string "i"
	o = append(o, 0xa1, 0x69)
	o = msgp.AppendString(o, z.ID)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendString(o, z.Tx)
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendString(o, z.Owner)
	// string "op"
	o = append(o, 0xa2, 0x6f, 0x70)
	o = msgp.AppendString(o, z.OwnerPublicKey)
	// string "sts"
	o = append(o, 0xa3, 0x73, 0x74, 0x73)
	if z.Stats == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Stats.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Stats")
			return
		}
	}
	// string "bs"
	o = append(o, 0xa2, 0x62, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Blobbers)))
	for za0001 := range z.Blobbers {
		if z.Blobbers[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Blobbers[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Blobbers", za0001)
				return
			}
		}
	}
	// string "bas"
	o = append(o, 0xa3, 0x62, 0x61, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BlobberAllocs)))
	for za0002 := range z.BlobberAllocs {
		if z.BlobberAllocs[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.BlobberAllocs[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "BlobberAllocs", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageAllocationDecode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "fo":
			z.FileOptions, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileOptions")
				return
			}
		case "d":
			z.DataShards, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DataShards")
				return
			}
		case "p":
			z.ParityShards, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ParityShards")
				return
			}
		case "s":
			z.Size, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "bz":
			z.BSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BSize")
				return
			}
		case "rp":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadPriceRange")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReadPriceRange")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Min":
					bts, err = z.ReadPriceRange.Min.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ReadPriceRange", "Min")
						return
					}
				case "Max":
					bts, err = z.ReadPriceRange.Max.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ReadPriceRange", "Max")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ReadPriceRange")
						return
					}
				}
			}
		case "wp":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WritePriceRange")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "WritePriceRange")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Min":
					bts, err = z.WritePriceRange.Min.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "WritePriceRange", "Min")
						return
					}
				case "Max":
					bts, err = z.WritePriceRange.Max.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "WritePriceRange", "Max")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "WritePriceRange")
						return
					}
				}
			}
		case "tpe":
			z.ThirdPartyExtendable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ThirdPartyExtendable")
				return
			}
		case "f":
			z.Finalized, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Finalized")
				return
			}
		case "c":
			z.Canceled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
		case "w":
			bts, err = z.WritePool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "WritePool")
				return
			}
		case "cp":
			bts, err = z.ChallengePool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengePool")
				return
			}
		case "mtc":
			bts, err = z.MovedToChallenge.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MovedToChallenge")
				return
			}
		case "mb":
			bts, err = z.MovedBack.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MovedBack")
				return
			}
		case "mv":
			bts, err = z.MovedToValidators.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MovedToValidators")
				return
			}
		case "cc":
			bts, err = z.CancelCost.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "CancelCost")
				return
			}
		case "ep":
			bts, err = z.Expiration.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Expiration")
				return
			}
		case "st":
			bts, err = z.StartTime.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "tu":
			z.TimeUnit, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TimeUnit")
				return
			}
		case "i":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "t":
			z.Tx, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tx")
				return
			}
		case "o":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "op":
			z.OwnerPublicKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OwnerPublicKey")
				return
			}
		case "sts":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Stats = nil
			} else {
				if z.Stats == nil {
					z.Stats = new(StorageAllocationStats)
				}
				bts, err = z.Stats.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stats")
					return
				}
			}
		case "bs":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Blobbers")
				return
			}
			if cap(z.Blobbers) >= int(zb0004) {
				z.Blobbers = (z.Blobbers)[:zb0004]
			} else {
				z.Blobbers = make([]*AllocBlobber, zb0004)
			}
			for za0001 := range z.Blobbers {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Blobbers[za0001] = nil
				} else {
					if z.Blobbers[za0001] == nil {
						z.Blobbers[za0001] = new(AllocBlobber)
					}
					bts, err = z.Blobbers[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Blobbers", za0001)
						return
					}
				}
			}
		case "bas":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberAllocs")
				return
			}
			if cap(z.BlobberAllocs) >= int(zb0005) {
				z.BlobberAllocs = (z.BlobberAllocs)[:zb0005]
			} else {
				z.BlobberAllocs = make([]*BlobberAllocation, zb0005)
			}
			for za0002 := range z.BlobberAllocs {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.BlobberAllocs[za0002] = nil
				} else {
					if z.BlobberAllocs[za0002] == nil {
						z.BlobberAllocs[za0002] = new(BlobberAllocation)
					}
					bts, err = z.BlobberAllocs[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "BlobberAllocs", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageAllocationDecode) Msgsize() (s int) {
	s = 3 + 3 + msgp.Uint16Size + 2 + msgp.IntSize + 2 + msgp.IntSize + 2 + msgp.Int64Size + 3 + msgp.Int64Size + 3 + 1 + 4 + z.ReadPriceRange.Min.Msgsize() + 4 + z.ReadPriceRange.Max.Msgsize() + 3 + 1 + 4 + z.WritePriceRange.Min.Msgsize() + 4 + z.WritePriceRange.Max.Msgsize() + 4 + msgp.BoolSize + 2 + msgp.BoolSize + 2 + msgp.BoolSize + 2 + z.WritePool.Msgsize() + 3 + z.ChallengePool.Msgsize() + 4 + z.MovedToChallenge.Msgsize() + 3 + z.MovedBack.Msgsize() + 3 + z.MovedToValidators.Msgsize() + 3 + z.CancelCost.Msgsize() + 3 + z.Expiration.Msgsize() + 3 + z.StartTime.Msgsize() + 3 + msgp.DurationSize + 2 + msgp.StringPrefixSize + len(z.ID) + 2 + msgp.StringPrefixSize + len(z.Tx) + 2 + msgp.StringPrefixSize + len(z.Owner) + 3 + msgp.StringPrefixSize + len(z.OwnerPublicKey) + 4
	if z.Stats == nil {
		s += msgp.NilSize
	} else {
		s += z.Stats.Msgsize()
	}
	s += 3 + msgp.ArrayHeaderSize
	for za0001 := range z.Blobbers {
		if z.Blobbers[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Blobbers[za0001].Msgsize()
		}
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0002 := range z.BlobberAllocs {
		if z.BlobberAllocs[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.BlobberAllocs[za0002].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageAllocationStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "u"
	o = append(o, 0x88, 0xa1, 0x75)
	o = msgp.AppendInt64(o, z.UsedSize)
	// string "nw"
	o = append(o, 0xa2, 0x6e, 0x77)
	o = msgp.AppendInt64(o, z.NumWrites)
	// string "nr"
	o = append(o, 0xa2, 0x6e, 0x72)
	o = msgp.AppendInt64(o, z.NumReads)
	// string "tc"
	o = append(o, 0xa2, 0x74, 0x63)
	o = msgp.AppendInt64(o, z.TotalChallenges)
	// string "oc"
	o = append(o, 0xa2, 0x6f, 0x63)
	o = msgp.AppendInt64(o, z.OpenChallenges)
	// string "sc"
	o = append(o, 0xa2, 0x73, 0x63)
	o = msgp.AppendInt64(o, z.SuccessChallenges)
	// string "fc"
	o = append(o, 0xa2, 0x66, 0x63)
	o = msgp.AppendInt64(o, z.FailedChallenges)
	// string "lcc"
	o = append(o, 0xa3, 0x6c, 0x63, 0x63)
	o = msgp.AppendString(o, z.LastestClosedChallengeTxn)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageAllocationStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "u":
			z.UsedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedSize")
				return
			}
		case "nw":
			z.NumWrites, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumWrites")
				return
			}
		case "nr":
			z.NumReads, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumReads")
				return
			}
		case "tc":
			z.TotalChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalChallenges")
				return
			}
		case "oc":
			z.OpenChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenChallenges")
				return
			}
		case "sc":
			z.SuccessChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SuccessChallenges")
				return
			}
		case "fc":
			z.FailedChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedChallenges")
				return
			}
		case "lcc":
			z.LastestClosedChallengeTxn, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastestClosedChallengeTxn")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageAllocationStats) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len(z.LastestClosedChallengeTxn)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageChallenge) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "tv"
	o = append(o, 0x87, 0xa2, 0x74, 0x76)
	o = msgp.AppendInt(o, z.TotalValidators)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendInt64(o, z.Responded)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o, err = z.Created.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Created")
		return
	}
	// string "i"
	o = append(o, 0xa1, 0x69)
	o = msgp.AppendString(o, z.ID)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendString(o, z.AllocationID)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BlobberID)
	// string "vs"
	o = append(o, 0xa2, 0x76, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ValidatorIDs)))
	for za0001 := range z.ValidatorIDs {
		o = msgp.AppendString(o, z.ValidatorIDs[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageChallenge) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "tv":
			z.TotalValidators, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalValidators")
				return
			}
		case "r":
			z.Responded, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Responded")
				return
			}
		case "c":
			bts, err = z.Created.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Created")
				return
			}
		case "i":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "a":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "b":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "vs":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidatorIDs")
				return
			}
			if cap(z.ValidatorIDs) >= int(zb0002) {
				z.ValidatorIDs = (z.ValidatorIDs)[:zb0002]
			} else {
				z.ValidatorIDs = make([]string, zb0002)
			}
			for za0001 := range z.ValidatorIDs {
				z.ValidatorIDs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ValidatorIDs", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageChallenge) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 2 + msgp.Int64Size + 2 + z.Created.Msgsize() + 2 + msgp.StringPrefixSize + len(z.ID) + 2 + msgp.StringPrefixSize + len(z.AllocationID) + 2 + msgp.StringPrefixSize + len(z.BlobberID) + 3 + msgp.ArrayHeaderSize
	for za0001 := range z.ValidatorIDs {
		s += msgp.StringPrefixSize + len(z.ValidatorIDs[za0001])
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageNode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "Provider"
	o = append(o, 0x8d, 0xa8, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72)
	o, err = z.Provider.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Provider")
		return
	}
	// string "Index"
	o = append(o, 0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt32(o, z.Index)
	// string "BaseURL"
	o = append(o, 0xa7, 0x42, 0x61, 0x73, 0x65, 0x55, 0x52, 0x4c)
	o = msgp.AppendString(o, z.BaseURL)
	// string "Geolocation"
	o = append(o, 0xab, 0x47, 0x65, 0x6f, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	// map header, size 2
	// string "Latitude"
	o = append(o, 0x82, 0xa8, 0x4c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Geolocation.Latitude)
	// string "Longitude"
	o = append(o, 0xa9, 0x4c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Geolocation.Longitude)
	// string "Terms"
	o = append(o, 0xa5, 0x54, 0x65, 0x72, 0x6d, 0x73)
	// map header, size 3
	// string "ReadPrice"
	o = append(o, 0x83, 0xa9, 0x52, 0x65, 0x61, 0x64, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.Terms.ReadPrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Terms", "ReadPrice")
		return
	}
	// string "WritePrice"
	o = append(o, 0xaa, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.Terms.WritePrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Terms", "WritePrice")
		return
	}
	// string "MinLockDemand"
	o = append(o, 0xad, 0x4d, 0x69, 0x6e, 0x4c, 0x6f, 0x63, 0x6b, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.Terms.MinLockDemand)
	// string "Capacity"
	o = append(o, 0xa8, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	o = msgp.AppendInt64(o, z.Capacity)
	// string "PublicKey"
	o = append(o, 0xa9, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.PublicKey)
	// string "SavedData"
	o = append(o, 0xa9, 0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendInt64(o, z.SavedData)
	// string "DataReadLastRewardRound"
	o = append(o, 0xb7, 0x44, 0x61, 0x74, 0x61, 0x52, 0x65, 0x61, 0x64, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.DataReadLastRewardRound)
	// string "LastRewardDataReadRound"
	o = append(o, 0xb7, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x44, 0x61, 0x74, 0x61, 0x52, 0x65, 0x61, 0x64, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendInt64(o, z.LastRewardDataReadRound)
	// string "StakePoolSettings"
	o = append(o, 0xb1, 0x53, 0x74, 0x61, 0x6b, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	o, err = z.StakePoolSettings.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "StakePoolSettings")
		return
	}
	// string "RewardRound"
	o = append(o, 0xab, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	// map header, size 2
	// string "StartRound"
	o = append(o, 0x82, 0xaa, 0x53, 0x74, 0x61, 0x72, 0x74, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendInt64(o, z.RewardRound.StartRound)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.RewardRound.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "RewardRound", "Timestamp")
		return
	}
	// string "IsAvailable"
	o = append(o, 0xab, 0x49, 0x73, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.IsAvailable)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageNode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Provider":
			bts, err = z.Provider.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Provider")
				return
			}
		case "Index":
			z.Index, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "BaseURL":
			z.BaseURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseURL")
				return
			}
		case "Geolocation":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Geolocation")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Geolocation")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Latitude":
					z.Geolocation.Latitude, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Geolocation", "Latitude")
						return
					}
				case "Longitude":
					z.Geolocation.Longitude, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Geolocation", "Longitude")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Geolocation")
						return
					}
				}
			}
		case "Terms":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Terms")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Terms")
					return
				}
				switch msgp.UnsafeString(field) {
				case "ReadPrice":
					bts, err = z.Terms.ReadPrice.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms", "ReadPrice")
						return
					}
				case "WritePrice":
					bts, err = z.Terms.WritePrice.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms", "WritePrice")
						return
					}
				case "MinLockDemand":
					z.Terms.MinLockDemand, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms", "MinLockDemand")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Terms")
						return
					}
				}
			}
		case "Capacity":
			z.Capacity, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Capacity")
				return
			}
		case "PublicKey":
			z.PublicKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PublicKey")
				return
			}
		case "SavedData":
			z.SavedData, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SavedData")
				return
			}
		case "DataReadLastRewardRound":
			z.DataReadLastRewardRound, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DataReadLastRewardRound")
				return
			}
		case "LastRewardDataReadRound":
			z.LastRewardDataReadRound, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastRewardDataReadRound")
				return
			}
		case "StakePoolSettings":
			bts, err = z.StakePoolSettings.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "StakePoolSettings")
				return
			}
		case "RewardRound":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RewardRound")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardRound")
					return
				}
				switch msgp.UnsafeString(field) {
				case "StartRound":
					z.RewardRound.StartRound, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RewardRound", "StartRound")
						return
					}
				case "Timestamp":
					bts, err = z.RewardRound.Timestamp.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "RewardRound", "Timestamp")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "RewardRound")
						return
					}
				}
			}
		case "IsAvailable":
			z.IsAvailable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsAvailable")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageNode) Msgsize() (s int) {
	s = 1 + 9 + z.Provider.Msgsize() + 6 + msgp.Int32Size + 8 + msgp.StringPrefixSize + len(z.BaseURL) + 12 + 1 + 9 + msgp.Float64Size + 10 + msgp.Float64Size + 6 + 1 + 10 + z.Terms.ReadPrice.Msgsize() + 11 + z.Terms.WritePrice.Msgsize() + 14 + msgp.Float64Size + 9 + msgp.Int64Size + 10 + msgp.StringPrefixSize + len(z.PublicKey) + 10 + msgp.Int64Size + 24 + msgp.Float64Size + 24 + msgp.Int64Size + 18 + z.StakePoolSettings.Msgsize() + 12 + 1 + 11 + msgp.Int64Size + 10 + z.RewardRound.Timestamp.Msgsize() + 12 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z StorageNodeGeolocation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Latitude"
	o = append(o, 0x82, 0xa8, 0x4c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Latitude)
	// string "Longitude"
	o = append(o, 0xa9, 0x4c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Longitude)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageNodeGeolocation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Latitude":
			z.Latitude, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Latitude")
				return
			}
		case "Longitude":
			z.Longitude, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Longitude")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z StorageNodeGeolocation) Msgsize() (s int) {
	s = 1 + 9 + msgp.Float64Size + 10 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageNodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Nodes"
	o = append(o, 0x81, 0xa5, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	o, err = z.Nodes.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Nodes")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageNodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Nodes":
			bts, err = z.Nodes.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageNodes) Msgsize() (s int) {
	s = 1 + 6 + z.Nodes.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Terms) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "ReadPrice"
	o = append(o, 0x83, 0xa9, 0x52, 0x65, 0x61, 0x64, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.ReadPrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadPrice")
		return
	}
	// string "WritePrice"
	o = append(o, 0xaa, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.WritePrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePrice")
		return
	}
	// string "MinLockDemand"
	o = append(o, 0xad, 0x4d, 0x69, 0x6e, 0x4c, 0x6f, 0x63, 0x6b, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.MinLockDemand)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Terms) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ReadPrice":
			bts, err = z.ReadPrice.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadPrice")
				return
			}
		case "WritePrice":
			bts, err = z.WritePrice.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "WritePrice")
				return
			}
		case "MinLockDemand":
			z.MinLockDemand, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinLockDemand")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Terms) Msgsize() (s int) {
	s = 1 + 10 + z.ReadPrice.Msgsize() + 11 + z.WritePrice.Msgsize() + 14 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ValidationNode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Provider"
	o = append(o, 0x84, 0xa8, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72)
	o, err = z.Provider.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Provider")
		return
	}
	// string "BaseURL"
	o = append(o, 0xa7, 0x42, 0x61, 0x73, 0x65, 0x55, 0x52, 0x4c)
	o = msgp.AppendString(o, z.BaseURL)
	// string "StakePoolSettings"
	o = append(o, 0xb1, 0x53, 0x74, 0x61, 0x6b, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	o, err = z.StakePoolSettings.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "StakePoolSettings")
		return
	}
	// string "LastHealthCheck"
	o = append(o, 0xaf, 0x4c, 0x61, 0x73, 0x74, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b)
	o, err = z.LastHealthCheck.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "LastHealthCheck")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ValidationNode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Provider":
			bts, err = z.Provider.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Provider")
				return
			}
		case "BaseURL":
			z.BaseURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseURL")
				return
			}
		case "StakePoolSettings":
			bts, err = z.StakePoolSettings.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "StakePoolSettings")
				return
			}
		case "LastHealthCheck":
			bts, err = z.LastHealthCheck.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastHealthCheck")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ValidationNode) Msgsize() (s int) {
	s = 1 + 9 + z.Provider.Msgsize() + 8 + msgp.StringPrefixSize + len(z.BaseURL) + 18 + z.StakePoolSettings.Msgsize() + 16 + z.LastHealthCheck.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ValidationTicket) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "ChallengeID"
	o = append(o, 0x89, 0xab, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x49, 0x44)
	o = msgp.AppendString(o, z.ChallengeID)
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	// string "ValidatorID"
	o = append(o, 0xab, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.ValidatorID)
	// string "ValidatorKey"
	o = append(o, 0xac, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.ValidatorKey)
	// string "Result"
	o = append(o, 0xa6, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74)
	o = msgp.AppendBool(o, z.Result)
	// string "Message"
	o = append(o, 0xa7, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.Message)
	// string "MessageCode"
	o = append(o, 0xab, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.MessageCode)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// string "Signature"
	o = append(o, 0xa9, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65)
	o = msgp.AppendString(o, z.Signature)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ValidationTicket) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ChallengeID":
			z.ChallengeID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengeID")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "ValidatorID":
			z.ValidatorID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidatorID")
				return
			}
		case "ValidatorKey":
			z.ValidatorKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidatorKey")
				return
			}
		case "Result":
			z.Result, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Result")
				return
			}
		case "Message":
			z.Message, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "MessageCode":
			z.MessageCode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MessageCode")
				return
			}
		case "Timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "Signature":
			z.Signature, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ValidationTicket) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ChallengeID) + 10 + msgp.StringPrefixSize + len(z.BlobberID) + 12 + msgp.StringPrefixSize + len(z.ValidatorID) + 13 + msgp.StringPrefixSize + len(z.ValidatorKey) + 7 + msgp.BoolSize + 8 + msgp.StringPrefixSize + len(z.Message) + 12 + msgp.StringPrefixSize + len(z.MessageCode) + 10 + z.Timestamp.Msgsize() + 10 + msgp.StringPrefixSize + len(z.Signature)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ValidatorNodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Nodes"
	o = append(o, 0x81, 0xa5, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Nodes)))
	for za0001 := range z.Nodes {
		if z.Nodes[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Nodes[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Nodes", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ValidatorNodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Nodes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			if cap(z.Nodes) >= int(zb0002) {
				z.Nodes = (z.Nodes)[:zb0002]
			} else {
				z.Nodes = make([]*ValidationNode, zb0002)
			}
			for za0001 := range z.Nodes {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Nodes[za0001] = nil
				} else {
					if z.Nodes[za0001] == nil {
						z.Nodes[za0001] = new(ValidationNode)
					}
					bts, err = z.Nodes[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Nodes", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ValidatorNodes) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Nodes {
		if z.Nodes[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Nodes[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WriteMarker) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "s"
	o = append(o, 0x89, 0xa1, 0x73)
	o = msgp.AppendInt64(o, z.Size)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// string "ar"
	o = append(o, 0xa2, 0x61, 0x72)
	o = msgp.AppendString(o, z.AllocationRoot)
	// string "pa"
	o = append(o, 0xa2, 0x70, 0x61)
	o = msgp.AppendString(o, z.PreviousAllocationRoot)
	// string "fmr"
	o = append(o, 0xa3, 0x66, 0x6d, 0x72)
	o = msgp.AppendString(o, z.FileMetaRoot)
	// string "a"
	o = append(o, 0xa1, 0x61)
	o = msgp.AppendString(o, z.AllocationID)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BlobberID)
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendString(o, z.ClientID)
	// string "sg"
	o = append(o, 0xa2, 0x73, 0x67)
	o = msgp.AppendString(o, z.Signature)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WriteMarker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			z.Size, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "t":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "ar":
			z.AllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationRoot")
				return
			}
		case "pa":
			z.PreviousAllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PreviousAllocationRoot")
				return
			}
		case "fmr":
			z.FileMetaRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileMetaRoot")
				return
			}
		case "a":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "b":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "c":
			z.ClientID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "sg":
			z.Signature, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WriteMarker) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int64Size + 2 + z.Timestamp.Msgsize() + 3 + msgp.StringPrefixSize + len(z.AllocationRoot) + 3 + msgp.StringPrefixSize + len(z.PreviousAllocationRoot) + 4 + msgp.StringPrefixSize + len(z.FileMetaRoot) + 2 + msgp.StringPrefixSize + len(z.AllocationID) + 2 + msgp.StringPrefixSize + len(z.BlobberID) + 2 + msgp.StringPrefixSize + len(z.ClientID) + 3 + msgp.StringPrefixSize + len(z.Signature)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *allocationChallengesDecoder) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "AllocationID"
	o = append(o, 0x82, 0xac, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.AllocationID)
	// string "OpenChallenges"
	o = append(o, 0xae, 0x4f, 0x70, 0x65, 0x6e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OpenChallenges)))
	for za0001 := range z.OpenChallenges {
		if z.OpenChallenges[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 3
			// string "ID"
			o = append(o, 0x83, 0xa2, 0x49, 0x44)
			o = msgp.AppendString(o, z.OpenChallenges[za0001].ID)
			// string "CreatedAt"
			o = append(o, 0xa9, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74)
			o, err = z.OpenChallenges[za0001].CreatedAt.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "OpenChallenges", za0001, "CreatedAt")
				return
			}
			// string "BlobberID"
			o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
			o = msgp.AppendString(o, z.OpenChallenges[za0001].BlobberID)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *allocationChallengesDecoder) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AllocationID":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "OpenChallenges":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenChallenges")
				return
			}
			if cap(z.OpenChallenges) >= int(zb0002) {
				z.OpenChallenges = (z.OpenChallenges)[:zb0002]
			} else {
				z.OpenChallenges = make([]*AllocOpenChallenge, zb0002)
			}
			for za0001 := range z.OpenChallenges {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.OpenChallenges[za0001] = nil
				} else {
					if z.OpenChallenges[za0001] == nil {
						z.OpenChallenges[za0001] = new(AllocOpenChallenge)
					}
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OpenChallenges", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "OpenChallenges", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "ID":
							z.OpenChallenges[za0001].ID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001, "ID")
								return
							}
						case "CreatedAt":
							bts, err = z.OpenChallenges[za0001].CreatedAt.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001, "CreatedAt")
								return
							}
						case "BlobberID":
							z.OpenChallenges[za0001].BlobberID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001, "BlobberID")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *allocationChallengesDecoder) Msgsize() (s int) {
	s = 1 + 13 + msgp.StringPrefixSize + len(z.AllocationID) + 15 + msgp.ArrayHeaderSize
	for za0001 := range z.OpenChallenges {
		if z.OpenChallenges[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 3 + msgp.StringPrefixSize + len(z.OpenChallenges[za0001].ID) + 10 + z.OpenChallenges[za0001].CreatedAt.Msgsize() + 10 + msgp.StringPrefixSize + len(z.OpenChallenges[za0001].BlobberID)
		}
	}
	return
}
