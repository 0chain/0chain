package storagesc

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"0chain.net/smartcontract/partitions"
	"github.com/tinylib/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *AllocOpenChallenge) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "ID"
	o = append(o, 0x83, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "CreatedAt"
	o = append(o, 0xa9, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74)
	o, err = z.CreatedAt.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "CreatedAt")
		return
	}
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AllocOpenChallenge) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "CreatedAt":
			bts, err = z.CreatedAt.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AllocOpenChallenge) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 10 + z.CreatedAt.Msgsize() + 10 + msgp.StringPrefixSize + len(z.BlobberID)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Allocations) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "List"
	o = append(o, 0x81, 0xa4, 0x4c, 0x69, 0x73, 0x74)
	o, err = z.List.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "List")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Allocations) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "List":
			bts, err = z.List.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "List")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Allocations) Msgsize() (s int) {
	s = 1 + 5 + z.List.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BlobberAllocation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 16
	// string "BlobberID"
	o = append(o, 0xde, 0x0, 0x10, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	// string "AllocationID"
	o = append(o, 0xac, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.AllocationID)
	// string "Size"
	o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt64(o, z.Size)
	// string "AllocationRoot"
	o = append(o, 0xae, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.AllocationRoot)
	// string "LastWriteMarker"
	o = append(o, 0xaf, 0x4c, 0x61, 0x73, 0x74, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72)
	if z.LastWriteMarker == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.LastWriteMarker.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LastWriteMarker")
			return
		}
	}
	// string "Stats"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x73)
	if z.Stats == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Stats.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Stats")
			return
		}
	}
	// string "Terms"
	o = append(o, 0xa5, 0x54, 0x65, 0x72, 0x6d, 0x73)
	o, err = z.Terms.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Terms")
		return
	}
	// string "MinLockDemand"
	o = append(o, 0xad, 0x4d, 0x69, 0x6e, 0x4c, 0x6f, 0x63, 0x6b, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64)
	o, err = z.MinLockDemand.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MinLockDemand")
		return
	}
	// string "Spent"
	o = append(o, 0xa5, 0x53, 0x70, 0x65, 0x6e, 0x74)
	o, err = z.Spent.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Spent")
		return
	}
	// string "Penalty"
	o = append(o, 0xa7, 0x50, 0x65, 0x6e, 0x61, 0x6c, 0x74, 0x79)
	o, err = z.Penalty.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Penalty")
		return
	}
	// string "ReadReward"
	o = append(o, 0xaa, 0x52, 0x65, 0x61, 0x64, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64)
	o, err = z.ReadReward.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadReward")
		return
	}
	// string "Returned"
	o = append(o, 0xa8, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64)
	o, err = z.Returned.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Returned")
		return
	}
	// string "ChallengeReward"
	o = append(o, 0xaf, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64)
	o, err = z.ChallengeReward.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ChallengeReward")
		return
	}
	// string "FinalReward"
	o = append(o, 0xab, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64)
	o, err = z.FinalReward.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "FinalReward")
		return
	}
	// string "ChallengePoolIntegralValue"
	o = append(o, 0xba, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x61, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o, err = z.ChallengePoolIntegralValue.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ChallengePoolIntegralValue")
		return
	}
	// string "BlobberAllocationsPartitionLoc"
	o = append(o, 0xbe, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x6f, 0x63)
	if z.BlobberAllocationsPartitionLoc == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.BlobberAllocationsPartitionLoc.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "BlobberAllocationsPartitionLoc")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlobberAllocation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "AllocationID":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "Size":
			z.Size, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "AllocationRoot":
			z.AllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationRoot")
				return
			}
		case "LastWriteMarker":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastWriteMarker = nil
			} else {
				if z.LastWriteMarker == nil {
					z.LastWriteMarker = new(WriteMarker)
				}
				bts, err = z.LastWriteMarker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastWriteMarker")
					return
				}
			}
		case "Stats":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Stats = nil
			} else {
				if z.Stats == nil {
					z.Stats = new(StorageAllocationStats)
				}
				bts, err = z.Stats.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stats")
					return
				}
			}
		case "Terms":
			bts, err = z.Terms.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Terms")
				return
			}
		case "MinLockDemand":
			bts, err = z.MinLockDemand.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinLockDemand")
				return
			}
		case "Spent":
			bts, err = z.Spent.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spent")
				return
			}
		case "Penalty":
			bts, err = z.Penalty.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Penalty")
				return
			}
		case "ReadReward":
			bts, err = z.ReadReward.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadReward")
				return
			}
		case "Returned":
			bts, err = z.Returned.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Returned")
				return
			}
		case "ChallengeReward":
			bts, err = z.ChallengeReward.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengeReward")
				return
			}
		case "FinalReward":
			bts, err = z.FinalReward.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "FinalReward")
				return
			}
		case "ChallengePoolIntegralValue":
			bts, err = z.ChallengePoolIntegralValue.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengePoolIntegralValue")
				return
			}
		case "BlobberAllocationsPartitionLoc":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BlobberAllocationsPartitionLoc = nil
			} else {
				if z.BlobberAllocationsPartitionLoc == nil {
					z.BlobberAllocationsPartitionLoc = new(partitions.PartitionLocation)
				}
				bts, err = z.BlobberAllocationsPartitionLoc.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BlobberAllocationsPartitionLoc")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlobberAllocation) Msgsize() (s int) {
	s = 3 + 10 + msgp.StringPrefixSize + len(z.BlobberID) + 13 + msgp.StringPrefixSize + len(z.AllocationID) + 5 + msgp.Int64Size + 15 + msgp.StringPrefixSize + len(z.AllocationRoot) + 16
	if z.LastWriteMarker == nil {
		s += msgp.NilSize
	} else {
		s += z.LastWriteMarker.Msgsize()
	}
	s += 6
	if z.Stats == nil {
		s += msgp.NilSize
	} else {
		s += z.Stats.Msgsize()
	}
	s += 6 + z.Terms.Msgsize() + 14 + z.MinLockDemand.Msgsize() + 6 + z.Spent.Msgsize() + 8 + z.Penalty.Msgsize() + 11 + z.ReadReward.Msgsize() + 9 + z.Returned.Msgsize() + 16 + z.ChallengeReward.Msgsize() + 12 + z.FinalReward.Msgsize() + 27 + z.ChallengePoolIntegralValue.Msgsize() + 31
	if z.BlobberAllocationsPartitionLoc == nil {
		s += msgp.NilSize
	} else {
		s += z.BlobberAllocationsPartitionLoc.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BlobberCloseConnection) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "AllocationRoot"
	o = append(o, 0x83, 0xae, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.AllocationRoot)
	// string "PrevAllocationRoot"
	o = append(o, 0xb2, 0x50, 0x72, 0x65, 0x76, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.PrevAllocationRoot)
	// string "WriteMarker"
	o = append(o, 0xab, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72)
	if z.WriteMarker == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.WriteMarker.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "WriteMarker")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlobberCloseConnection) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AllocationRoot":
			z.AllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationRoot")
				return
			}
		case "PrevAllocationRoot":
			z.PrevAllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PrevAllocationRoot")
				return
			}
		case "WriteMarker":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.WriteMarker = nil
			} else {
				if z.WriteMarker == nil {
					z.WriteMarker = new(WriteMarker)
				}
				bts, err = z.WriteMarker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "WriteMarker")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlobberCloseConnection) Msgsize() (s int) {
	s = 1 + 15 + msgp.StringPrefixSize + len(z.AllocationRoot) + 19 + msgp.StringPrefixSize + len(z.PrevAllocationRoot) + 12
	if z.WriteMarker == nil {
		s += msgp.NilSize
	} else {
		s += z.WriteMarker.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChallengeResponse) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "ID"
	o = append(o, 0x82, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "ValidationTickets"
	o = append(o, 0xb1, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ValidationTickets)))
	for za0001 := range z.ValidationTickets {
		if z.ValidationTickets[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.ValidationTickets[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ValidationTickets", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChallengeResponse) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ValidationTickets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidationTickets")
				return
			}
			if cap(z.ValidationTickets) >= int(zb0002) {
				z.ValidationTickets = (z.ValidationTickets)[:zb0002]
			} else {
				z.ValidationTickets = make([]*ValidationTicket, zb0002)
			}
			for za0001 := range z.ValidationTickets {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.ValidationTickets[za0001] = nil
				} else {
					if z.ValidationTickets[za0001] == nil {
						z.ValidationTickets[za0001] = new(ValidationTicket)
					}
					bts, err = z.ValidationTickets[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ValidationTickets", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChallengeResponse) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 18 + msgp.ArrayHeaderSize
	for za0001 := range z.ValidationTickets {
		if z.ValidationTickets[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.ValidationTickets[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Info) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Name"
	o = append(o, 0x84, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "WebsiteUrl"
	o = append(o, 0xaa, 0x57, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x55, 0x72, 0x6c)
	o = msgp.AppendString(o, z.WebsiteUrl)
	// string "LogoUrl"
	o = append(o, 0xa7, 0x4c, 0x6f, 0x67, 0x6f, 0x55, 0x72, 0x6c)
	o = msgp.AppendString(o, z.LogoUrl)
	// string "Description"
	o = append(o, 0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Info) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "WebsiteUrl":
			z.WebsiteUrl, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WebsiteUrl")
				return
			}
		case "LogoUrl":
			z.LogoUrl, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LogoUrl")
				return
			}
		case "Description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Info) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 11 + msgp.StringPrefixSize + len(z.WebsiteUrl) + 8 + msgp.StringPrefixSize + len(z.LogoUrl) + 12 + msgp.StringPrefixSize + len(z.Description)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PriceRange) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Min"
	o = append(o, 0x82, 0xa3, 0x4d, 0x69, 0x6e)
	o, err = z.Min.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o, err = z.Max.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PriceRange) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Min":
			bts, err = z.Min.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Min")
				return
			}
		case "Max":
			bts, err = z.Max.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PriceRange) Msgsize() (s int) {
	s = 1 + 4 + z.Min.Msgsize() + 4 + z.Max.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReadConnection) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "ReadMarker"
	o = append(o, 0x81, 0xaa, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72)
	if z.ReadMarker == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ReadMarker.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ReadMarker")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadConnection) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ReadMarker":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ReadMarker = nil
			} else {
				if z.ReadMarker == nil {
					z.ReadMarker = new(ReadMarker)
				}
				bts, err = z.ReadMarker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReadMarker")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReadConnection) Msgsize() (s int) {
	s = 1 + 11
	if z.ReadMarker == nil {
		s += msgp.NilSize
	} else {
		s += z.ReadMarker.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReadMarker) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "ClientID"
	o = append(o, 0x89, 0xa8, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44)
	o = msgp.AppendString(o, z.ClientID)
	// string "ClientPublicKey"
	o = append(o, 0xaf, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.ClientPublicKey)
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	// string "AllocationID"
	o = append(o, 0xac, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.AllocationID)
	// string "OwnerID"
	o = append(o, 0xa7, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.OwnerID)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// string "ReadCounter"
	o = append(o, 0xab, 0x52, 0x65, 0x61, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72)
	o = msgp.AppendInt64(o, z.ReadCounter)
	// string "Signature"
	o = append(o, 0xa9, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65)
	o = msgp.AppendString(o, z.Signature)
	// string "ReadSize"
	o = append(o, 0xa8, 0x52, 0x65, 0x61, 0x64, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendFloat64(o, z.ReadSize)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadMarker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ClientID":
			z.ClientID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "ClientPublicKey":
			z.ClientPublicKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientPublicKey")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "AllocationID":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "OwnerID":
			z.OwnerID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OwnerID")
				return
			}
		case "Timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "ReadCounter":
			z.ReadCounter, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadCounter")
				return
			}
		case "Signature":
			z.Signature, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		case "ReadSize":
			z.ReadSize, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadSize")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReadMarker) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.ClientID) + 16 + msgp.StringPrefixSize + len(z.ClientPublicKey) + 10 + msgp.StringPrefixSize + len(z.BlobberID) + 13 + msgp.StringPrefixSize + len(z.AllocationID) + 8 + msgp.StringPrefixSize + len(z.OwnerID) + 10 + z.Timestamp.Msgsize() + 12 + msgp.Int64Size + 10 + msgp.StringPrefixSize + len(z.Signature) + 9 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RewardPartitionLocation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Index"
	o = append(o, 0x83, 0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.Index)
	// string "StartRound"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x72, 0x74, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendInt64(o, z.StartRound)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RewardPartitionLocation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Index":
			z.Index, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Index")
				return
			}
		case "StartRound":
			z.StartRound, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartRound")
				return
			}
		case "Timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RewardPartitionLocation) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 11 + msgp.Int64Size + 10 + z.Timestamp.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageAllocationDecode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 28
	// string "ID"
	o = append(o, 0xde, 0x0, 0x1c, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "Tx"
	o = append(o, 0xa2, 0x54, 0x78)
	o = msgp.AppendString(o, z.Tx)
	// string "DataShards"
	o = append(o, 0xaa, 0x44, 0x61, 0x74, 0x61, 0x53, 0x68, 0x61, 0x72, 0x64, 0x73)
	o = msgp.AppendInt(o, z.DataShards)
	// string "ParityShards"
	o = append(o, 0xac, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79, 0x53, 0x68, 0x61, 0x72, 0x64, 0x73)
	o = msgp.AppendInt(o, z.ParityShards)
	// string "Size"
	o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt64(o, z.Size)
	// string "Expiration"
	o = append(o, 0xaa, 0x45, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o, err = z.Expiration.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Expiration")
		return
	}
	// string "Owner"
	o = append(o, 0xa5, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	// string "OwnerPublicKey"
	o = append(o, 0xae, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.OwnerPublicKey)
	// string "Stats"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x73)
	if z.Stats == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Stats.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Stats")
			return
		}
	}
	// string "DiverseBlobbers"
	o = append(o, 0xaf, 0x44, 0x69, 0x76, 0x65, 0x72, 0x73, 0x65, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendBool(o, z.DiverseBlobbers)
	// string "PreferredBlobbers"
	o = append(o, 0xb1, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PreferredBlobbers)))
	for za0001 := range z.PreferredBlobbers {
		o = msgp.AppendString(o, z.PreferredBlobbers[za0001])
	}
	// string "BlobberAllocs"
	o = append(o, 0xad, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BlobberAllocs)))
	for za0002 := range z.BlobberAllocs {
		if z.BlobberAllocs[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.BlobberAllocs[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "BlobberAllocs", za0002)
				return
			}
		}
	}
	// string "IsImmutable"
	o = append(o, 0xab, 0x49, 0x73, 0x49, 0x6d, 0x6d, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.IsImmutable)
	// string "ThirdPartyExtendable"
	o = append(o, 0xb4, 0x54, 0x68, 0x69, 0x72, 0x64, 0x50, 0x61, 0x72, 0x74, 0x79, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.ThirdPartyExtendable)
	// string "FileOptions"
	o = append(o, 0xab, 0x46, 0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendUint8(o, z.FileOptions)
	// string "WritePool"
	o = append(o, 0xa9, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x6f, 0x6f, 0x6c)
	o, err = z.WritePool.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePool")
		return
	}
	// string "ReadPriceRange"
	o = append(o, 0xae, 0x52, 0x65, 0x61, 0x64, 0x50, 0x72, 0x69, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65)
	// map header, size 2
	// string "Min"
	o = append(o, 0x82, 0xa3, 0x4d, 0x69, 0x6e)
	o, err = z.ReadPriceRange.Min.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadPriceRange", "Min")
		return
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o, err = z.ReadPriceRange.Max.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadPriceRange", "Max")
		return
	}
	// string "WritePriceRange"
	o = append(o, 0xaf, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x72, 0x69, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65)
	// map header, size 2
	// string "Min"
	o = append(o, 0x82, 0xa3, 0x4d, 0x69, 0x6e)
	o, err = z.WritePriceRange.Min.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePriceRange", "Min")
		return
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o, err = z.WritePriceRange.Max.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePriceRange", "Max")
		return
	}
	// string "ChallengeCompletionTime"
	o = append(o, 0xb7, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendDuration(o, z.ChallengeCompletionTime)
	// string "StartTime"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o, err = z.StartTime.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// string "Finalized"
	o = append(o, 0xa9, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Finalized)
	// string "Canceled"
	o = append(o, 0xa8, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Canceled)
	// string "MovedToChallenge"
	o = append(o, 0xb0, 0x4d, 0x6f, 0x76, 0x65, 0x64, 0x54, 0x6f, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65)
	o, err = z.MovedToChallenge.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MovedToChallenge")
		return
	}
	// string "MovedBack"
	o = append(o, 0xa9, 0x4d, 0x6f, 0x76, 0x65, 0x64, 0x42, 0x61, 0x63, 0x6b)
	o, err = z.MovedBack.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MovedBack")
		return
	}
	// string "MovedToValidators"
	o = append(o, 0xb1, 0x4d, 0x6f, 0x76, 0x65, 0x64, 0x54, 0x6f, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x73)
	o, err = z.MovedToValidators.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MovedToValidators")
		return
	}
	// string "TimeUnit"
	o = append(o, 0xa8, 0x54, 0x69, 0x6d, 0x65, 0x55, 0x6e, 0x69, 0x74)
	o = msgp.AppendDuration(o, z.TimeUnit)
	// string "Curators"
	o = append(o, 0xa8, 0x43, 0x75, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Curators)))
	for za0003 := range z.Curators {
		o = msgp.AppendString(o, z.Curators[za0003])
	}
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageAllocationDecode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Tx":
			z.Tx, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tx")
				return
			}
		case "DataShards":
			z.DataShards, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DataShards")
				return
			}
		case "ParityShards":
			z.ParityShards, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ParityShards")
				return
			}
		case "Size":
			z.Size, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "Expiration":
			bts, err = z.Expiration.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Expiration")
				return
			}
		case "Owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "OwnerPublicKey":
			z.OwnerPublicKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OwnerPublicKey")
				return
			}
		case "Stats":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Stats = nil
			} else {
				if z.Stats == nil {
					z.Stats = new(StorageAllocationStats)
				}
				bts, err = z.Stats.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stats")
					return
				}
			}
		case "DiverseBlobbers":
			z.DiverseBlobbers, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiverseBlobbers")
				return
			}
		case "PreferredBlobbers":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PreferredBlobbers")
				return
			}
			if cap(z.PreferredBlobbers) >= int(zb0002) {
				z.PreferredBlobbers = (z.PreferredBlobbers)[:zb0002]
			} else {
				z.PreferredBlobbers = make([]string, zb0002)
			}
			for za0001 := range z.PreferredBlobbers {
				z.PreferredBlobbers[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PreferredBlobbers", za0001)
					return
				}
			}
		case "BlobberAllocs":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberAllocs")
				return
			}
			if cap(z.BlobberAllocs) >= int(zb0003) {
				z.BlobberAllocs = (z.BlobberAllocs)[:zb0003]
			} else {
				z.BlobberAllocs = make([]*BlobberAllocation, zb0003)
			}
			for za0002 := range z.BlobberAllocs {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.BlobberAllocs[za0002] = nil
				} else {
					if z.BlobberAllocs[za0002] == nil {
						z.BlobberAllocs[za0002] = new(BlobberAllocation)
					}
					bts, err = z.BlobberAllocs[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "BlobberAllocs", za0002)
						return
					}
				}
			}
		case "IsImmutable":
			z.IsImmutable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsImmutable")
				return
			}
		case "ThirdPartyExtendable":
			z.ThirdPartyExtendable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ThirdPartyExtendable")
				return
			}
		case "FileOptions":
			z.FileOptions, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileOptions")
				return
			}
		case "WritePool":
			bts, err = z.WritePool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "WritePool")
				return
			}
		case "ReadPriceRange":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadPriceRange")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReadPriceRange")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Min":
					bts, err = z.ReadPriceRange.Min.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ReadPriceRange", "Min")
						return
					}
				case "Max":
					bts, err = z.ReadPriceRange.Max.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ReadPriceRange", "Max")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ReadPriceRange")
						return
					}
				}
			}
		case "WritePriceRange":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WritePriceRange")
				return
			}
			for zb0005 > 0 {
				zb0005--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "WritePriceRange")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Min":
					bts, err = z.WritePriceRange.Min.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "WritePriceRange", "Min")
						return
					}
				case "Max":
					bts, err = z.WritePriceRange.Max.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "WritePriceRange", "Max")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "WritePriceRange")
						return
					}
				}
			}
		case "ChallengeCompletionTime":
			z.ChallengeCompletionTime, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengeCompletionTime")
				return
			}
		case "StartTime":
			bts, err = z.StartTime.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "Finalized":
			z.Finalized, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Finalized")
				return
			}
		case "Canceled":
			z.Canceled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
		case "MovedToChallenge":
			bts, err = z.MovedToChallenge.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MovedToChallenge")
				return
			}
		case "MovedBack":
			bts, err = z.MovedBack.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MovedBack")
				return
			}
		case "MovedToValidators":
			bts, err = z.MovedToValidators.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MovedToValidators")
				return
			}
		case "TimeUnit":
			z.TimeUnit, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TimeUnit")
				return
			}
		case "Curators":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Curators")
				return
			}
			if cap(z.Curators) >= int(zb0006) {
				z.Curators = (z.Curators)[:zb0006]
			} else {
				z.Curators = make([]string, zb0006)
			}
			for za0003 := range z.Curators {
				z.Curators[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Curators", za0003)
					return
				}
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageAllocationDecode) Msgsize() (s int) {
	s = 3 + 3 + msgp.StringPrefixSize + len(z.ID) + 3 + msgp.StringPrefixSize + len(z.Tx) + 11 + msgp.IntSize + 13 + msgp.IntSize + 5 + msgp.Int64Size + 11 + z.Expiration.Msgsize() + 6 + msgp.StringPrefixSize + len(z.Owner) + 15 + msgp.StringPrefixSize + len(z.OwnerPublicKey) + 6
	if z.Stats == nil {
		s += msgp.NilSize
	} else {
		s += z.Stats.Msgsize()
	}
	s += 16 + msgp.BoolSize + 18 + msgp.ArrayHeaderSize
	for za0001 := range z.PreferredBlobbers {
		s += msgp.StringPrefixSize + len(z.PreferredBlobbers[za0001])
	}
	s += 14 + msgp.ArrayHeaderSize
	for za0002 := range z.BlobberAllocs {
		if z.BlobberAllocs[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.BlobberAllocs[za0002].Msgsize()
		}
	}
	s += 12 + msgp.BoolSize + 21 + msgp.BoolSize + 12 + msgp.Uint8Size + 10 + z.WritePool.Msgsize() + 15 + 1 + 4 + z.ReadPriceRange.Min.Msgsize() + 4 + z.ReadPriceRange.Max.Msgsize() + 16 + 1 + 4 + z.WritePriceRange.Min.Msgsize() + 4 + z.WritePriceRange.Max.Msgsize() + 24 + msgp.DurationSize + 10 + z.StartTime.Msgsize() + 10 + msgp.BoolSize + 9 + msgp.BoolSize + 17 + z.MovedToChallenge.Msgsize() + 10 + z.MovedBack.Msgsize() + 18 + z.MovedToValidators.Msgsize() + 9 + msgp.DurationSize + 9 + msgp.ArrayHeaderSize
	for za0003 := range z.Curators {
		s += msgp.StringPrefixSize + len(z.Curators[za0003])
	}
	s += 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageAllocationStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "UsedSize"
	o = append(o, 0x88, 0xa8, 0x55, 0x73, 0x65, 0x64, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt64(o, z.UsedSize)
	// string "NumWrites"
	o = append(o, 0xa9, 0x4e, 0x75, 0x6d, 0x57, 0x72, 0x69, 0x74, 0x65, 0x73)
	o = msgp.AppendInt64(o, z.NumWrites)
	// string "NumReads"
	o = append(o, 0xa8, 0x4e, 0x75, 0x6d, 0x52, 0x65, 0x61, 0x64, 0x73)
	o = msgp.AppendInt64(o, z.NumReads)
	// string "TotalChallenges"
	o = append(o, 0xaf, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73)
	o = msgp.AppendInt64(o, z.TotalChallenges)
	// string "OpenChallenges"
	o = append(o, 0xae, 0x4f, 0x70, 0x65, 0x6e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73)
	o = msgp.AppendInt64(o, z.OpenChallenges)
	// string "SuccessChallenges"
	o = append(o, 0xb1, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73)
	o = msgp.AppendInt64(o, z.SuccessChallenges)
	// string "FailedChallenges"
	o = append(o, 0xb0, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73)
	o = msgp.AppendInt64(o, z.FailedChallenges)
	// string "LastestClosedChallengeTxn"
	o = append(o, 0xb9, 0x4c, 0x61, 0x73, 0x74, 0x65, 0x73, 0x74, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x54, 0x78, 0x6e)
	o = msgp.AppendString(o, z.LastestClosedChallengeTxn)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageAllocationStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "UsedSize":
			z.UsedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedSize")
				return
			}
		case "NumWrites":
			z.NumWrites, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumWrites")
				return
			}
		case "NumReads":
			z.NumReads, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumReads")
				return
			}
		case "TotalChallenges":
			z.TotalChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalChallenges")
				return
			}
		case "OpenChallenges":
			z.OpenChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenChallenges")
				return
			}
		case "SuccessChallenges":
			z.SuccessChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SuccessChallenges")
				return
			}
		case "FailedChallenges":
			z.FailedChallenges, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedChallenges")
				return
			}
		case "LastestClosedChallengeTxn":
			z.LastestClosedChallengeTxn, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastestClosedChallengeTxn")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageAllocationStats) Msgsize() (s int) {
	s = 1 + 9 + msgp.Int64Size + 10 + msgp.Int64Size + 9 + msgp.Int64Size + 16 + msgp.Int64Size + 15 + msgp.Int64Size + 18 + msgp.Int64Size + 17 + msgp.Int64Size + 26 + msgp.StringPrefixSize + len(z.LastestClosedChallengeTxn)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageChallenge) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "Created"
	o = append(o, 0x87, 0xa7, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64)
	o, err = z.Created.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Created")
		return
	}
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "TotalValidators"
	o = append(o, 0xaf, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x73)
	o = msgp.AppendInt(o, z.TotalValidators)
	// string "ValidatorIDs"
	o = append(o, 0xac, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ValidatorIDs)))
	for za0001 := range z.ValidatorIDs {
		o = msgp.AppendString(o, z.ValidatorIDs[za0001])
	}
	// string "AllocationID"
	o = append(o, 0xac, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.AllocationID)
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	// string "Responded"
	o = append(o, 0xa9, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Responded)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageChallenge) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Created":
			bts, err = z.Created.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Created")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "TotalValidators":
			z.TotalValidators, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalValidators")
				return
			}
		case "ValidatorIDs":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidatorIDs")
				return
			}
			if cap(z.ValidatorIDs) >= int(zb0002) {
				z.ValidatorIDs = (z.ValidatorIDs)[:zb0002]
			} else {
				z.ValidatorIDs = make([]string, zb0002)
			}
			for za0001 := range z.ValidatorIDs {
				z.ValidatorIDs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ValidatorIDs", za0001)
					return
				}
			}
		case "AllocationID":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "Responded":
			z.Responded, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Responded")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageChallenge) Msgsize() (s int) {
	s = 1 + 8 + z.Created.Msgsize() + 3 + msgp.StringPrefixSize + len(z.ID) + 16 + msgp.IntSize + 13 + msgp.ArrayHeaderSize
	for za0001 := range z.ValidatorIDs {
		s += msgp.StringPrefixSize + len(z.ValidatorIDs[za0001])
	}
	s += 13 + msgp.StringPrefixSize + len(z.AllocationID) + 10 + msgp.StringPrefixSize + len(z.BlobberID) + 10 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageNode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 15
	// string "ID"
	o = append(o, 0x8f, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "BaseURL"
	o = append(o, 0xa7, 0x42, 0x61, 0x73, 0x65, 0x55, 0x52, 0x4c)
	o = msgp.AppendString(o, z.BaseURL)
	// string "Geolocation"
	o = append(o, 0xab, 0x47, 0x65, 0x6f, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	// map header, size 2
	// string "Latitude"
	o = append(o, 0x82, 0xa8, 0x4c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Geolocation.Latitude)
	// string "Longitude"
	o = append(o, 0xa9, 0x4c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Geolocation.Longitude)
	// string "Terms"
	o = append(o, 0xa5, 0x54, 0x65, 0x72, 0x6d, 0x73)
	o, err = z.Terms.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Terms")
		return
	}
	// string "Capacity"
	o = append(o, 0xa8, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	o = msgp.AppendInt64(o, z.Capacity)
	// string "Allocated"
	o = append(o, 0xa9, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.Allocated)
	// string "DataRead"
	o = append(o, 0xa8, 0x44, 0x61, 0x74, 0x61, 0x52, 0x65, 0x61, 0x64)
	o = msgp.AppendFloat64(o, z.DataRead)
	// string "LastHealthCheck"
	o = append(o, 0xaf, 0x4c, 0x61, 0x73, 0x74, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b)
	o, err = z.LastHealthCheck.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "LastHealthCheck")
		return
	}
	// string "PublicKey"
	o = append(o, 0xa9, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.PublicKey)
	// string "SavedData"
	o = append(o, 0xa9, 0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendInt64(o, z.SavedData)
	// string "DataReadLastRewardRound"
	o = append(o, 0xb7, 0x44, 0x61, 0x74, 0x61, 0x52, 0x65, 0x61, 0x64, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.DataReadLastRewardRound)
	// string "LastRewardDataReadRound"
	o = append(o, 0xb7, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x44, 0x61, 0x74, 0x61, 0x52, 0x65, 0x61, 0x64, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendInt64(o, z.LastRewardDataReadRound)
	// string "StakePoolSettings"
	o = append(o, 0xb1, 0x53, 0x74, 0x61, 0x6b, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	o, err = z.StakePoolSettings.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "StakePoolSettings")
		return
	}
	// string "RewardPartition"
	o = append(o, 0xaf, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e)
	// map header, size 3
	// string "Index"
	o = append(o, 0x83, 0xa5, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.RewardPartition.Index)
	// string "StartRound"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x72, 0x74, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendInt64(o, z.RewardPartition.StartRound)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.RewardPartition.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "RewardPartition", "Timestamp")
		return
	}
	// string "Information"
	o = append(o, 0xab, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o, err = z.Information.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Information")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageNode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "BaseURL":
			z.BaseURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseURL")
				return
			}
		case "Geolocation":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Geolocation")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Geolocation")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Latitude":
					z.Geolocation.Latitude, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Geolocation", "Latitude")
						return
					}
				case "Longitude":
					z.Geolocation.Longitude, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Geolocation", "Longitude")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Geolocation")
						return
					}
				}
			}
		case "Terms":
			bts, err = z.Terms.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Terms")
				return
			}
		case "Capacity":
			z.Capacity, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Capacity")
				return
			}
		case "Allocated":
			z.Allocated, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Allocated")
				return
			}
		case "DataRead":
			z.DataRead, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DataRead")
				return
			}
		case "LastHealthCheck":
			bts, err = z.LastHealthCheck.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastHealthCheck")
				return
			}
		case "PublicKey":
			z.PublicKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PublicKey")
				return
			}
		case "SavedData":
			z.SavedData, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SavedData")
				return
			}
		case "DataReadLastRewardRound":
			z.DataReadLastRewardRound, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DataReadLastRewardRound")
				return
			}
		case "LastRewardDataReadRound":
			z.LastRewardDataReadRound, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastRewardDataReadRound")
				return
			}
		case "StakePoolSettings":
			bts, err = z.StakePoolSettings.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "StakePoolSettings")
				return
			}
		case "RewardPartition":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RewardPartition")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardPartition")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Index":
					z.RewardPartition.Index, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RewardPartition", "Index")
						return
					}
				case "StartRound":
					z.RewardPartition.StartRound, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RewardPartition", "StartRound")
						return
					}
				case "Timestamp":
					bts, err = z.RewardPartition.Timestamp.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "RewardPartition", "Timestamp")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "RewardPartition")
						return
					}
				}
			}
		case "Information":
			bts, err = z.Information.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Information")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageNode) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.BaseURL) + 12 + 1 + 9 + msgp.Float64Size + 10 + msgp.Float64Size + 6 + z.Terms.Msgsize() + 9 + msgp.Int64Size + 10 + msgp.Int64Size + 9 + msgp.Float64Size + 16 + z.LastHealthCheck.Msgsize() + 10 + msgp.StringPrefixSize + len(z.PublicKey) + 10 + msgp.Int64Size + 24 + msgp.Float64Size + 24 + msgp.Int64Size + 18 + z.StakePoolSettings.Msgsize() + 16 + 1 + 6 + msgp.IntSize + 11 + msgp.Int64Size + 10 + z.RewardPartition.Timestamp.Msgsize() + 12 + z.Information.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z StorageNodeGeolocation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Latitude"
	o = append(o, 0x82, 0xa8, 0x4c, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Latitude)
	// string "Longitude"
	o = append(o, 0xa9, 0x4c, 0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65)
	o = msgp.AppendFloat64(o, z.Longitude)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageNodeGeolocation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Latitude":
			z.Latitude, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Latitude")
				return
			}
		case "Longitude":
			z.Longitude, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Longitude")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z StorageNodeGeolocation) Msgsize() (s int) {
	s = 1 + 9 + msgp.Float64Size + 10 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageNodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Nodes"
	o = append(o, 0x81, 0xa5, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	o, err = z.Nodes.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Nodes")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageNodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Nodes":
			bts, err = z.Nodes.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageNodes) Msgsize() (s int) {
	s = 1 + 6 + z.Nodes.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Terms) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "ReadPrice"
	o = append(o, 0x84, 0xa9, 0x52, 0x65, 0x61, 0x64, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.ReadPrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ReadPrice")
		return
	}
	// string "WritePrice"
	o = append(o, 0xaa, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x72, 0x69, 0x63, 0x65)
	o, err = z.WritePrice.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "WritePrice")
		return
	}
	// string "MinLockDemand"
	o = append(o, 0xad, 0x4d, 0x69, 0x6e, 0x4c, 0x6f, 0x63, 0x6b, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64)
	o = msgp.AppendFloat64(o, z.MinLockDemand)
	// string "MaxOfferDuration"
	o = append(o, 0xb0, 0x4d, 0x61, 0x78, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendDuration(o, z.MaxOfferDuration)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Terms) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ReadPrice":
			bts, err = z.ReadPrice.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadPrice")
				return
			}
		case "WritePrice":
			bts, err = z.WritePrice.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "WritePrice")
				return
			}
		case "MinLockDemand":
			z.MinLockDemand, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinLockDemand")
				return
			}
		case "MaxOfferDuration":
			z.MaxOfferDuration, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxOfferDuration")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Terms) Msgsize() (s int) {
	s = 1 + 10 + z.ReadPrice.Msgsize() + 11 + z.WritePrice.Msgsize() + 14 + msgp.Float64Size + 17 + msgp.DurationSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ValidationNode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "ID"
	o = append(o, 0x83, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "BaseURL"
	o = append(o, 0xa7, 0x42, 0x61, 0x73, 0x65, 0x55, 0x52, 0x4c)
	o = msgp.AppendString(o, z.BaseURL)
	// string "StakePoolSettings"
	o = append(o, 0xb1, 0x53, 0x74, 0x61, 0x6b, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	o, err = z.StakePoolSettings.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "StakePoolSettings")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ValidationNode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "BaseURL":
			z.BaseURL, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseURL")
				return
			}
		case "StakePoolSettings":
			bts, err = z.StakePoolSettings.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "StakePoolSettings")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ValidationNode) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.BaseURL) + 18 + z.StakePoolSettings.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ValidationTicket) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "ChallengeID"
	o = append(o, 0x89, 0xab, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x49, 0x44)
	o = msgp.AppendString(o, z.ChallengeID)
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	// string "ValidatorID"
	o = append(o, 0xab, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.ValidatorID)
	// string "ValidatorKey"
	o = append(o, 0xac, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.ValidatorKey)
	// string "Result"
	o = append(o, 0xa6, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74)
	o = msgp.AppendBool(o, z.Result)
	// string "Message"
	o = append(o, 0xa7, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.Message)
	// string "MessageCode"
	o = append(o, 0xab, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.MessageCode)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// string "Signature"
	o = append(o, 0xa9, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65)
	o = msgp.AppendString(o, z.Signature)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ValidationTicket) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ChallengeID":
			z.ChallengeID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChallengeID")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "ValidatorID":
			z.ValidatorID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidatorID")
				return
			}
		case "ValidatorKey":
			z.ValidatorKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ValidatorKey")
				return
			}
		case "Result":
			z.Result, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Result")
				return
			}
		case "Message":
			z.Message, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "MessageCode":
			z.MessageCode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MessageCode")
				return
			}
		case "Timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "Signature":
			z.Signature, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ValidationTicket) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ChallengeID) + 10 + msgp.StringPrefixSize + len(z.BlobberID) + 12 + msgp.StringPrefixSize + len(z.ValidatorID) + 13 + msgp.StringPrefixSize + len(z.ValidatorKey) + 7 + msgp.BoolSize + 8 + msgp.StringPrefixSize + len(z.Message) + 12 + msgp.StringPrefixSize + len(z.MessageCode) + 10 + z.Timestamp.Msgsize() + 10 + msgp.StringPrefixSize + len(z.Signature)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ValidatorNodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Nodes"
	o = append(o, 0x81, 0xa5, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Nodes)))
	for za0001 := range z.Nodes {
		if z.Nodes[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 3
			// string "ID"
			o = append(o, 0x83, 0xa2, 0x49, 0x44)
			o = msgp.AppendString(o, z.Nodes[za0001].ID)
			// string "BaseURL"
			o = append(o, 0xa7, 0x42, 0x61, 0x73, 0x65, 0x55, 0x52, 0x4c)
			o = msgp.AppendString(o, z.Nodes[za0001].BaseURL)
			// string "StakePoolSettings"
			o = append(o, 0xb1, 0x53, 0x74, 0x61, 0x6b, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
			o, err = z.Nodes[za0001].StakePoolSettings.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Nodes", za0001, "StakePoolSettings")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ValidatorNodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Nodes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			if cap(z.Nodes) >= int(zb0002) {
				z.Nodes = (z.Nodes)[:zb0002]
			} else {
				z.Nodes = make([]*ValidationNode, zb0002)
			}
			for za0001 := range z.Nodes {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Nodes[za0001] = nil
				} else {
					if z.Nodes[za0001] == nil {
						z.Nodes[za0001] = new(ValidationNode)
					}
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Nodes", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Nodes", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "ID":
							z.Nodes[za0001].ID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Nodes", za0001, "ID")
								return
							}
						case "BaseURL":
							z.Nodes[za0001].BaseURL, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Nodes", za0001, "BaseURL")
								return
							}
						case "StakePoolSettings":
							bts, err = z.Nodes[za0001].StakePoolSettings.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Nodes", za0001, "StakePoolSettings")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Nodes", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ValidatorNodes) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Nodes {
		if z.Nodes[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 3 + msgp.StringPrefixSize + len(z.Nodes[za0001].ID) + 8 + msgp.StringPrefixSize + len(z.Nodes[za0001].BaseURL) + 18 + z.Nodes[za0001].StakePoolSettings.Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WriteMarker) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "AllocationRoot"
	o = append(o, 0x8b, 0xae, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.AllocationRoot)
	// string "PreviousAllocationRoot"
	o = append(o, 0xb6, 0x50, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x6f, 0x6f, 0x74)
	o = msgp.AppendString(o, z.PreviousAllocationRoot)
	// string "AllocationID"
	o = append(o, 0xac, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.AllocationID)
	// string "Size"
	o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt64(o, z.Size)
	// string "BlobberID"
	o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
	o = msgp.AppendString(o, z.BlobberID)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o, err = z.Timestamp.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// string "ClientID"
	o = append(o, 0xa8, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44)
	o = msgp.AppendString(o, z.ClientID)
	// string "Signature"
	o = append(o, 0xa9, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65)
	o = msgp.AppendString(o, z.Signature)
	// string "LookupHash"
	o = append(o, 0xaa, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x48, 0x61, 0x73, 0x68)
	o = msgp.AppendString(o, z.LookupHash)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "ContentHash"
	o = append(o, 0xab, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x73, 0x68)
	o = msgp.AppendString(o, z.ContentHash)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WriteMarker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AllocationRoot":
			z.AllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationRoot")
				return
			}
		case "PreviousAllocationRoot":
			z.PreviousAllocationRoot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PreviousAllocationRoot")
				return
			}
		case "AllocationID":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "Size":
			z.Size, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "BlobberID":
			z.BlobberID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BlobberID")
				return
			}
		case "Timestamp":
			bts, err = z.Timestamp.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "ClientID":
			z.ClientID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientID")
				return
			}
		case "Signature":
			z.Signature, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Signature")
				return
			}
		case "LookupHash":
			z.LookupHash, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LookupHash")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "ContentHash":
			z.ContentHash, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContentHash")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WriteMarker) Msgsize() (s int) {
	s = 1 + 15 + msgp.StringPrefixSize + len(z.AllocationRoot) + 23 + msgp.StringPrefixSize + len(z.PreviousAllocationRoot) + 13 + msgp.StringPrefixSize + len(z.AllocationID) + 5 + msgp.Int64Size + 10 + msgp.StringPrefixSize + len(z.BlobberID) + 10 + z.Timestamp.Msgsize() + 9 + msgp.StringPrefixSize + len(z.ClientID) + 10 + msgp.StringPrefixSize + len(z.Signature) + 11 + msgp.StringPrefixSize + len(z.LookupHash) + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.ContentHash)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *allocationChallengesDecoder) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "AllocationID"
	o = append(o, 0x83, 0xac, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44)
	o = msgp.AppendString(o, z.AllocationID)
	// string "OpenChallenges"
	o = append(o, 0xae, 0x4f, 0x70, 0x65, 0x6e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OpenChallenges)))
	for za0001 := range z.OpenChallenges {
		if z.OpenChallenges[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 3
			// string "ID"
			o = append(o, 0x83, 0xa2, 0x49, 0x44)
			o = msgp.AppendString(o, z.OpenChallenges[za0001].ID)
			// string "CreatedAt"
			o = append(o, 0xa9, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74)
			o, err = z.OpenChallenges[za0001].CreatedAt.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "OpenChallenges", za0001, "CreatedAt")
				return
			}
			// string "BlobberID"
			o = append(o, 0xa9, 0x42, 0x6c, 0x6f, 0x62, 0x62, 0x65, 0x72, 0x49, 0x44)
			o = msgp.AppendString(o, z.OpenChallenges[za0001].BlobberID)
		}
	}
	// string "LatestCompletedChallenge"
	o = append(o, 0xb8, 0x4c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65)
	if z.LatestCompletedChallenge == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.LatestCompletedChallenge.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LatestCompletedChallenge")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *allocationChallengesDecoder) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AllocationID":
			z.AllocationID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocationID")
				return
			}
		case "OpenChallenges":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OpenChallenges")
				return
			}
			if cap(z.OpenChallenges) >= int(zb0002) {
				z.OpenChallenges = (z.OpenChallenges)[:zb0002]
			} else {
				z.OpenChallenges = make([]*AllocOpenChallenge, zb0002)
			}
			for za0001 := range z.OpenChallenges {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.OpenChallenges[za0001] = nil
				} else {
					if z.OpenChallenges[za0001] == nil {
						z.OpenChallenges[za0001] = new(AllocOpenChallenge)
					}
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OpenChallenges", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "OpenChallenges", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "ID":
							z.OpenChallenges[za0001].ID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001, "ID")
								return
							}
						case "CreatedAt":
							bts, err = z.OpenChallenges[za0001].CreatedAt.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001, "CreatedAt")
								return
							}
						case "BlobberID":
							z.OpenChallenges[za0001].BlobberID, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001, "BlobberID")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "OpenChallenges", za0001)
								return
							}
						}
					}
				}
			}
		case "LatestCompletedChallenge":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LatestCompletedChallenge = nil
			} else {
				if z.LatestCompletedChallenge == nil {
					z.LatestCompletedChallenge = new(StorageChallenge)
				}
				bts, err = z.LatestCompletedChallenge.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LatestCompletedChallenge")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *allocationChallengesDecoder) Msgsize() (s int) {
	s = 1 + 13 + msgp.StringPrefixSize + len(z.AllocationID) + 15 + msgp.ArrayHeaderSize
	for za0001 := range z.OpenChallenges {
		if z.OpenChallenges[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 3 + msgp.StringPrefixSize + len(z.OpenChallenges[za0001].ID) + 10 + z.OpenChallenges[za0001].CreatedAt.Msgsize() + 10 + msgp.StringPrefixSize + len(z.OpenChallenges[za0001].BlobberID)
		}
	}
	s += 25
	if z.LatestCompletedChallenge == nil {
		s += msgp.NilSize
	} else {
		s += z.LatestCompletedChallenge.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *blobberPartitionsLocations) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "ID"
	o = append(o, 0x82, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "ChallengeReadyPartitionLoc"
	o = append(o, 0xba, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x65, 0x61, 0x64, 0x79, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x6f, 0x63)
	if z.ChallengeReadyPartitionLoc == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ChallengeReadyPartitionLoc.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ChallengeReadyPartitionLoc")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *blobberPartitionsLocations) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ChallengeReadyPartitionLoc":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ChallengeReadyPartitionLoc = nil
			} else {
				if z.ChallengeReadyPartitionLoc == nil {
					z.ChallengeReadyPartitionLoc = new(partitions.PartitionLocation)
				}
				bts, err = z.ChallengeReadyPartitionLoc.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ChallengeReadyPartitionLoc")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *blobberPartitionsLocations) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 27
	if z.ChallengeReadyPartitionLoc == nil {
		s += msgp.NilSize
	} else {
		s += z.ChallengeReadyPartitionLoc.Msgsize()
	}
	return
}
