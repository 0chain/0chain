// Code generated by mockery v3.0.0-alpha.0. DO NOT EDIT.

package mocks

import (
	config "0chain.net/chaincore/config"
	currency "github.com/0chain/common/core/currency"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// ChainConfig is an autogenerated mock type for the ChainConfig type
type ChainConfig struct {
	mock.Mock
}

// BlockProposalMaxWaitTime provides a mock function with given fields:
func (_m *ChainConfig) BlockProposalMaxWaitTime() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// BlockProposalWaitMode provides a mock function with given fields:
func (_m *ChainConfig) BlockProposalWaitMode() int8 {
	ret := _m.Called()

	var r0 int8
	if rf, ok := ret.Get(0).(func() int8); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int8)
	}

	return r0
}

// BlocksToSharder provides a mock function with given fields:
func (_m *ChainConfig) BlocksToSharder() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// ClientSignatureScheme provides a mock function with given fields:
func (_m *ChainConfig) ClientSignatureScheme() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// DbSettings provides a mock function with given fields:
func (_m *ChainConfig) DbSettings() config.DbSettings {
	ret := _m.Called()

	var r0 config.DbSettings
	if rf, ok := ret.Get(0).(func() config.DbSettings); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(config.DbSettings)
	}

	return r0
}

// DbsEvents provides a mock function with given fields:
func (_m *ChainConfig) DbsEvents() config.DbAccess {
	ret := _m.Called()

	var r0 config.DbAccess
	if rf, ok := ret.Get(0).(func() config.DbAccess); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(config.DbAccess)
	}

	return r0
}

// FromViper provides a mock function with given fields:
func (_m *ChainConfig) FromViper() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GeneratorsPercent provides a mock function with given fields:
func (_m *ChainConfig) GeneratorsPercent() float64 {
	ret := _m.Called()

	var r0 float64
	if rf, ok := ret.Get(0).(func() float64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(float64)
	}

	return r0
}

// HCCycleScan provides a mock function with given fields:
func (_m *ChainConfig) HCCycleScan() [2]config.HealthCheckCycleScan {
	ret := _m.Called()

	var r0 [2]config.HealthCheckCycleScan
	if rf, ok := ret.Get(0).(func() [2]config.HealthCheckCycleScan); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([2]config.HealthCheckCycleScan)
		}
	}

	return r0
}

// HealthShowCounters provides a mock function with given fields:
func (_m *ChainConfig) HealthShowCounters() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsBlockRewardsEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsBlockRewardsEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsDkgEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsDkgEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsFaucetEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsFaucetEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsFeeEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsFeeEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsInterestEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsInterestEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsMultisigEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsMultisigEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsStateEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsStateEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsStorageEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsStorageEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsVestingEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsVestingEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsViewChangeEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsViewChangeEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsZcnEnabled provides a mock function with given fields:
func (_m *ChainConfig) IsZcnEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MaxBlockCost provides a mock function with given fields:
func (_m *ChainConfig) MaxBlockCost() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MaxByteSize provides a mock function with given fields:
func (_m *ChainConfig) MaxByteSize() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// MinActiveReplicators provides a mock function with given fields:
func (_m *ChainConfig) MinActiveReplicators() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MinActiveSharders provides a mock function with given fields:
func (_m *ChainConfig) MinActiveSharders() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MinBlockSize provides a mock function with given fields:
func (_m *ChainConfig) MinBlockSize() int32 {
	ret := _m.Called()

	var r0 int32
	if rf, ok := ret.Get(0).(func() int32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// MinGenerators provides a mock function with given fields:
func (_m *ChainConfig) MinGenerators() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MinTxnFee provides a mock function with given fields:
func (_m *ChainConfig) MinTxnFee() currency.Coin {
	ret := _m.Called()

	var r0 currency.Coin
	if rf, ok := ret.Get(0).(func() currency.Coin); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(currency.Coin)
	}

	return r0
}

// NumReplicators provides a mock function with given fields:
func (_m *ChainConfig) NumReplicators() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// OwnerID provides a mock function with given fields:
func (_m *ChainConfig) OwnerID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PruneStateBelowCount provides a mock function with given fields:
func (_m *ChainConfig) PruneStateBelowCount() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// ReuseTransactions provides a mock function with given fields:
func (_m *ChainConfig) ReuseTransactions() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// RoundRange provides a mock function with given fields:
func (_m *ChainConfig) RoundRange() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// RoundRestartMult provides a mock function with given fields:
func (_m *ChainConfig) RoundRestartMult() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// RoundTimeoutSofttoMin provides a mock function with given fields:
func (_m *ChainConfig) RoundTimeoutSofttoMin() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// RoundTimeoutSofttoMult provides a mock function with given fields:
func (_m *ChainConfig) RoundTimeoutSofttoMult() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// SmartContractSettingUpdatePeriod provides a mock function with given fields:
func (_m *ChainConfig) SmartContractSettingUpdatePeriod() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// SmartContractTimeout provides a mock function with given fields:
func (_m *ChainConfig) SmartContractTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// ThresholdByCount provides a mock function with given fields:
func (_m *ChainConfig) ThresholdByCount() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// ThresholdByStake provides a mock function with given fields:
func (_m *ChainConfig) ThresholdByStake() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// TxnExempt provides a mock function with given fields:
func (_m *ChainConfig) TxnExempt() map[string]bool {
	ret := _m.Called()

	var r0 map[string]bool
	if rf, ok := ret.Get(0).(func() map[string]bool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]bool)
		}
	}

	return r0
}

// TxnMaxPayload provides a mock function with given fields:
func (_m *ChainConfig) TxnMaxPayload() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// TxnTransferCost provides a mock function with given fields:
func (_m *ChainConfig) TxnTransferCost() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Update provides a mock function with given fields: configMap, version
func (_m *ChainConfig) Update(configMap map[string]string, version int64) error {
	ret := _m.Called(configMap, version)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]string, int64) error); ok {
		r0 = rf(configMap, version)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidationBatchSize provides a mock function with given fields:
func (_m *ChainConfig) ValidationBatchSize() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// VerificationTicketsTo provides a mock function with given fields:
func (_m *ChainConfig) VerificationTicketsTo() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

type mockConstructorTestingTNewChainConfig interface {
	mock.TestingT
	Cleanup(func())
}

// NewChainConfig creates a new instance of ChainConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewChainConfig(t mockConstructorTestingTNewChainConfig) *ChainConfig {
	mock := &ChainConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
