// Code generated by mockery v3.0.0-alpha.0. DO NOT EDIT.

package mocks

import (
	block "0chain.net/chaincore/block"
	mock "github.com/stretchr/testify/mock"

	node "0chain.net/chaincore/node"

	round "0chain.net/chaincore/round"
)

// RoundI is an autogenerated mock type for the RoundI type
type RoundI struct {
	mock.Mock
}

// AddNotarizedBlock provides a mock function with given fields: b
func (_m *RoundI) AddNotarizedBlock(b *block.Block) {
	_m.Called(b)
}

// AddProposedBlock provides a mock function with given fields: b
func (_m *RoundI) AddProposedBlock(b *block.Block) {
	_m.Called(b)
}

// AddVRFShare provides a mock function with given fields: share, threshold
func (_m *RoundI) AddVRFShare(share *round.VRFShare, threshold int) bool {
	ret := _m.Called(share, threshold)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*round.VRFShare, int) bool); ok {
		r0 = rf(share, threshold)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Clear provides a mock function with given fields:
func (_m *RoundI) Clear() {
	_m.Called()
}

// Clone provides a mock function with given fields:
func (_m *RoundI) Clone() round.RoundI {
	ret := _m.Called()

	var r0 round.RoundI
	if rf, ok := ret.Get(0).(func() round.RoundI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(round.RoundI)
		}
	}

	return r0
}

// Finalize provides a mock function with given fields: b
func (_m *RoundI) Finalize(b *block.Block) {
	_m.Called(b)
}

// GetBestRankedNotarizedBlock provides a mock function with given fields:
func (_m *RoundI) GetBestRankedNotarizedBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetBestRankedProposedBlock provides a mock function with given fields:
func (_m *RoundI) GetBestRankedProposedBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetBlockHash provides a mock function with given fields:
func (_m *RoundI) GetBlockHash() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetHeaviestNotarizedBlock provides a mock function with given fields:
func (_m *RoundI) GetHeaviestNotarizedBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetMinerRank provides a mock function with given fields: miner
func (_m *RoundI) GetMinerRank(miner *node.Node) int {
	ret := _m.Called(miner)

	var r0 int
	if rf, ok := ret.Get(0).(func(*node.Node) int); ok {
		r0 = rf(miner)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetMinersByRank provides a mock function with given fields: miners
func (_m *RoundI) GetMinersByRank(miners []*node.Node) []*node.Node {
	ret := _m.Called(miners)

	var r0 []*node.Node
	if rf, ok := ret.Get(0).(func([]*node.Node) []*node.Node); ok {
		r0 = rf(miners)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*node.Node)
		}
	}

	return r0
}

// GetNotarizedBlocks provides a mock function with given fields:
func (_m *RoundI) GetNotarizedBlocks() []*block.Block {
	ret := _m.Called()

	var r0 []*block.Block
	if rf, ok := ret.Get(0).(func() []*block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*block.Block)
		}
	}

	return r0
}

// GetPhase provides a mock function with given fields:
func (_m *RoundI) GetPhase() round.Phase {
	ret := _m.Called()

	var r0 round.Phase
	if rf, ok := ret.Get(0).(func() round.Phase); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(round.Phase)
	}

	return r0
}

// GetProposedBlocks provides a mock function with given fields:
func (_m *RoundI) GetProposedBlocks() []*block.Block {
	ret := _m.Called()

	var r0 []*block.Block
	if rf, ok := ret.Get(0).(func() []*block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*block.Block)
		}
	}

	return r0
}

// GetRandomSeed provides a mock function with given fields:
func (_m *RoundI) GetRandomSeed() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GetRoundNumber provides a mock function with given fields:
func (_m *RoundI) GetRoundNumber() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GetTimeoutCount provides a mock function with given fields:
func (_m *RoundI) GetTimeoutCount() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetVRFShares provides a mock function with given fields:
func (_m *RoundI) GetVRFShares() map[string]*round.VRFShare {
	ret := _m.Called()

	var r0 map[string]*round.VRFShare
	if rf, ok := ret.Get(0).(func() map[string]*round.VRFShare); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*round.VRFShare)
		}
	}

	return r0
}

// HasRandomSeed provides a mock function with given fields:
func (_m *RoundI) HasRandomSeed() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsFinalized provides a mock function with given fields:
func (_m *RoundI) IsFinalized() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsFinalizing provides a mock function with given fields:
func (_m *RoundI) IsFinalizing() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsRanksComputed provides a mock function with given fields:
func (_m *RoundI) IsRanksComputed() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SetFinalizing provides a mock function with given fields:
func (_m *RoundI) SetFinalizing() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SetPhase provides a mock function with given fields: state
func (_m *RoundI) SetPhase(state round.Phase) {
	_m.Called(state)
}

// SetRandomSeed provides a mock function with given fields: seed, minersNum
func (_m *RoundI) SetRandomSeed(seed int64, minersNum int) {
	_m.Called(seed, minersNum)
}

// SetRandomSeedForNotarizedBlock provides a mock function with given fields: seed, minersNum
func (_m *RoundI) SetRandomSeedForNotarizedBlock(seed int64, minersNum int) {
	_m.Called(seed, minersNum)
}

// SetTimeoutCount provides a mock function with given fields: tc
func (_m *RoundI) SetTimeoutCount(tc int) bool {
	ret := _m.Called(tc)

	var r0 bool
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(tc)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// UpdateNotarizedBlock provides a mock function with given fields: b
func (_m *RoundI) UpdateNotarizedBlock(b *block.Block) {
	_m.Called(b)
}

type mockConstructorTestingTNewRoundI interface {
	mock.TestingT
	Cleanup(func())
}

// NewRoundI creates a new instance of RoundI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewRoundI(t mockConstructorTestingTNewRoundI) *RoundI {
	mock := &RoundI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
