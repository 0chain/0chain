// Code generated by mockery v3.0.0-alpha.0. DO NOT EDIT.

package mocks

import (
	block "0chain.net/chaincore/block"
	chainstate "0chain.net/chaincore/chain/state"

	currency "github.com/0chain/common/core/currency"

	encryption "0chain.net/core/encryption"

	event "0chain.net/smartcontract/dbs/event"

	mock "github.com/stretchr/testify/mock"

	state "0chain.net/chaincore/state"

	transaction "0chain.net/chaincore/transaction"

	util "github.com/0chain/common/core/util"
)

// StateContextI is an autogenerated mock type for the StateContextI type
type StateContextI struct {
	mock.Mock
}

// AddMint provides a mock function with given fields: m
func (_m *StateContextI) AddMint(m *state.Mint) error {
	ret := _m.Called(m)

	var r0 error
	if rf, ok := ret.Get(0).(func(*state.Mint) error); ok {
		r0 = rf(m)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddSignedTransfer provides a mock function with given fields: st
func (_m *StateContextI) AddSignedTransfer(st *state.SignedTransfer) {
	_m.Called(st)
}

// AddTransfer provides a mock function with given fields: t
func (_m *StateContextI) AddTransfer(t *state.Transfer) error {
	ret := _m.Called(t)

	var r0 error
	if rf, ok := ret.Get(0).(func(*state.Transfer) error); ok {
		r0 = rf(t)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTrieNode provides a mock function with given fields: key
func (_m *StateContextI) DeleteTrieNode(key string) (string, error) {
	ret := _m.Called(key)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EmitError provides a mock function with given fields: _a0
func (_m *StateContextI) EmitError(_a0 error) {
	_m.Called(_a0)
}

// EmitEvent provides a mock function with given fields: eventType, eventTag, index, data, appender
func (_m *StateContextI) EmitEvent(eventType event.EventType, eventTag event.EventTag, index string, data interface{}, appender ...chainstate.Appender) {
	_va := make([]interface{}, len(appender))
	for _i := range appender {
		_va[_i] = appender[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, eventType, eventTag, index, data)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// GetBlock provides a mock function with given fields:
func (_m *StateContextI) GetBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetChainCurrentMagicBlock provides a mock function with given fields:
func (_m *StateContextI) GetChainCurrentMagicBlock() *block.MagicBlock {
	ret := _m.Called()

	var r0 *block.MagicBlock
	if rf, ok := ret.Get(0).(func() *block.MagicBlock); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.MagicBlock)
		}
	}

	return r0
}

// GetClientBalance provides a mock function with given fields: clientID
func (_m *StateContextI) GetClientBalance(clientID string) (currency.Coin, error) {
	ret := _m.Called(clientID)

	var r0 currency.Coin
	if rf, ok := ret.Get(0).(func(string) currency.Coin); ok {
		r0 = rf(clientID)
	} else {
		r0 = ret.Get(0).(currency.Coin)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientState provides a mock function with given fields: clientID
func (_m *StateContextI) GetClientState(clientID string) (*state.State, error) {
	ret := _m.Called(clientID)

	var r0 *state.State
	if rf, ok := ret.Get(0).(func(string) *state.State); ok {
		r0 = rf(clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.State)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEventDB provides a mock function with given fields:
func (_m *StateContextI) GetEventDB() *event.EventDb {
	ret := _m.Called()

	var r0 *event.EventDb
	if rf, ok := ret.Get(0).(func() *event.EventDb); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*event.EventDb)
		}
	}

	return r0
}

// GetEvents provides a mock function with given fields:
func (_m *StateContextI) GetEvents() []event.Event {
	ret := _m.Called()

	var r0 []event.Event
	if rf, ok := ret.Get(0).(func() []event.Event); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]event.Event)
		}
	}

	return r0
}

// GetLastestFinalizedMagicBlock provides a mock function with given fields:
func (_m *StateContextI) GetLastestFinalizedMagicBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetLatestFinalizedBlock provides a mock function with given fields:
func (_m *StateContextI) GetLatestFinalizedBlock() *block.Block {
	ret := _m.Called()

	var r0 *block.Block
	if rf, ok := ret.Get(0).(func() *block.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.Block)
		}
	}

	return r0
}

// GetMagicBlock provides a mock function with given fields: round
func (_m *StateContextI) GetMagicBlock(round int64) *block.MagicBlock {
	ret := _m.Called(round)

	var r0 *block.MagicBlock
	if rf, ok := ret.Get(0).(func(int64) *block.MagicBlock); ok {
		r0 = rf(round)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*block.MagicBlock)
		}
	}

	return r0
}

// GetMints provides a mock function with given fields:
func (_m *StateContextI) GetMints() []*state.Mint {
	ret := _m.Called()

	var r0 []*state.Mint
	if rf, ok := ret.Get(0).(func() []*state.Mint); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.Mint)
		}
	}

	return r0
}

// GetMissingNodeKeys provides a mock function with given fields:
func (_m *StateContextI) GetMissingNodeKeys() []util.Key {
	ret := _m.Called()

	var r0 []util.Key
	if rf, ok := ret.Get(0).(func() []util.Key); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]util.Key)
		}
	}

	return r0
}

// GetSignatureScheme provides a mock function with given fields:
func (_m *StateContextI) GetSignatureScheme() encryption.SignatureScheme {
	ret := _m.Called()

	var r0 encryption.SignatureScheme
	if rf, ok := ret.Get(0).(func() encryption.SignatureScheme); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(encryption.SignatureScheme)
		}
	}

	return r0
}

// GetSignedTransfers provides a mock function with given fields:
func (_m *StateContextI) GetSignedTransfers() []*state.SignedTransfer {
	ret := _m.Called()

	var r0 []*state.SignedTransfer
	if rf, ok := ret.Get(0).(func() []*state.SignedTransfer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.SignedTransfer)
		}
	}

	return r0
}

// GetState provides a mock function with given fields:
func (_m *StateContextI) GetState() util.MerklePatriciaTrieI {
	ret := _m.Called()

	var r0 util.MerklePatriciaTrieI
	if rf, ok := ret.Get(0).(func() util.MerklePatriciaTrieI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(util.MerklePatriciaTrieI)
		}
	}

	return r0
}

// GetTransaction provides a mock function with given fields:
func (_m *StateContextI) GetTransaction() *transaction.Transaction {
	ret := _m.Called()

	var r0 *transaction.Transaction
	if rf, ok := ret.Get(0).(func() *transaction.Transaction); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transaction.Transaction)
		}
	}

	return r0
}

// GetTransfers provides a mock function with given fields:
func (_m *StateContextI) GetTransfers() []*state.Transfer {
	ret := _m.Called()

	var r0 []*state.Transfer
	if rf, ok := ret.Get(0).(func() []*state.Transfer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*state.Transfer)
		}
	}

	return r0
}

// GetTrieNode provides a mock function with given fields: key, v
func (_m *StateContextI) GetTrieNode(key string, v util.MPTSerializable) error {
	ret := _m.Called(key, v)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, util.MPTSerializable) error); ok {
		r0 = rf(key, v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertTrieNode provides a mock function with given fields: key, v
func (_m *StateContextI) InsertTrieNode(key string, v util.MPTSerializable) (string, error) {
	ret := _m.Called(key, v)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, util.MPTSerializable) string); ok {
		r0 = rf(key, v)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, util.MPTSerializable) error); ok {
		r1 = rf(key, v)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetClientState provides a mock function with given fields: clientID, s
func (_m *StateContextI) SetClientState(clientID string, s *state.State) (util.Key, error) {
	ret := _m.Called(clientID, s)

	var r0 util.Key
	if rf, ok := ret.Get(0).(func(string, *state.State) util.Key); ok {
		r0 = rf(clientID, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(util.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *state.State) error); ok {
		r1 = rf(clientID, s)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetMagicBlock provides a mock function with given fields: _a0
func (_m *StateContextI) SetMagicBlock(_a0 *block.MagicBlock) {
	_m.Called(_a0)
}

// SetStateContext provides a mock function with given fields: st
func (_m *StateContextI) SetStateContext(st *state.State) error {
	ret := _m.Called(st)

	var r0 error
	if rf, ok := ret.Get(0).(func(*state.State) error); ok {
		r0 = rf(st)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Validate provides a mock function with given fields:
func (_m *StateContextI) Validate() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewStateContextI interface {
	mock.TestingT
	Cleanup(func())
}

// NewStateContextI creates a new instance of StateContextI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewStateContextI(t mockConstructorTestingTNewStateContextI) *StateContextI {
	mock := &StateContextI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
